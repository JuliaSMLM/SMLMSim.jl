var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides a comprehensive reference for the types and functions in SMLMSim.","category":"section"},{"location":"api/#SMLMSim.SMLMSim","page":"API Reference","title":"SMLMSim.SMLMSim","text":"SMLMSim\n\nMain module for the SMLMSim.jl package.\n\nAPI Overview\n\nFor a comprehensive overview of the API, use the help mode on api:\n\n?api\n\nOr access the complete API documentation programmatically:\n\ndocs = SMLMSim.api()\n\nThis package provides tools for simulating Single Molecule Localization Microscopy (SMLM) data. It includes modules for:\n\nCore: Fundamental types (molecules, patterns) and photophysics simulation (CTMC, blinking).\nStaticSMLM: Simulating static emitters with blinking and localization noise.\nInteractionDiffusion: Simulating diffusing and interacting emitters (e.g., dimerization) using Smoluchowski dynamics.\nCameraImages: Generating simulated camera images from emitter data, including noise models.\n\nThe main SMLMSim module re-exports key types and functions from these submodules to provide a unified user interface.\n\nUsage\n\nusing SMLMSim\n\n# Example: Static simulation\nparams_static = StaticSMLMParams(density=1.0, σ_psf=0.13)\n_, _, smld_noisy = simulate(params_static)\n\n# Example: Diffusion simulation\nparams_diff = DiffusionSMLMParams(density=0.5, diff_monomer=0.1)\nsmld_diff = simulate(params_diff)\n\n# Example: Generate images\npsf = GaussianPSF(0.15)\nimages = gen_images(smld_noisy, psf)\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMSim.api-Tuple{}","page":"API Reference","title":"SMLMSim.api","text":"SMLMSim.jl API Overview\n\nSMLMSim is a Julia package for simulating Single Molecule Localization Microscopy (SMLM) data with realistic physical properties. It provides tools for generating static SMLM simulations, diffusion-interaction simulations, and microscope image generation.\n\nKey Concepts\n\nPhysical Units\n\nAll simulations use consistent physical units:\n\nSpatial dimensions: microns (μm)\nTime: seconds (s)\nDiffusion coefficients: μm²/s\nRate constants: s⁻¹\n\nCore Components\n\nPatterns: Spatial arrangements of molecules (e.g., oligomers, lines)\nMolecules: Photophysical models of fluorophores with state transitions\nSimulation: Parameters and functions for different simulation types\nNoise: Realistic localization uncertainty based on photon statistics\nCamera Images: Generation of microscope images from simulation data\n\nType Hierarchy\n\nAbstractSim: Base type for all simulation types\nSMLMSimParams: Base type for simulation parameters\nStaticSMLMParams: Parameters for static SMLM simulation\nDiffusionSMLMParams: Parameters for diffusion simulation\nPattern: Base type for all molecular patterns\nPattern2D: Base type for 2D patterns\nNmer2D: N molecules arranged in a circle\nLine2D: Molecules arranged along a line\nPattern3D: Base type for 3D patterns\nNmer3D: N molecules arranged in a circle in 3D\nLine3D: Molecules arranged along a 3D line\nMolecule: Base type for all photophysical models\nGenericFluor: General fluorophore with kinetic state model\nAbstractDiffusingEmitter: Base type for diffusing emitters\nDiffusingEmitter2D: 2D emitter with diffusion state\nDiffusingEmitter3D: 3D emitter with diffusion state\n\nEssential Types\n\nStaticSMLMParams\n\nParameters for static SMLM simulation with fixed molecular patterns.\n\nBase.@kwdef mutable struct StaticSMLMParams <: SMLMSimParams\n    density::Float64 = 1.0          # density in particles per square micron\n    σ_psf::Float64 = 0.13           # PSF width in microns\n    minphotons::Int = 50            # minimum photons for detection\n    ndatasets::Int = 10             # number of datasets to simulate\n    nframes::Int = 1000             # number of frames per dataset\n    framerate::Float64 = 50.0       # frames per second\n    ndims::Int = 2                  # dimensionality (2 or 3)\n    zrange::Vector{Float64} = [-1.0, 1.0]  # axial range for 3D simulations [min_z, max_z]\nend\n\nDiffusionSMLMParams\n\nParameters for diffusion-based SMLM simulation using Smoluchowski dynamics.\n\nBase.@kwdef mutable struct DiffusionSMLMParams <: SMLMSimParams\n    density::Float64 = 1.0          # number density (molecules/μm²)\n    box_size::Float64 = 10.0        # simulation box size (μm)\n    diff_monomer::Float64 = 0.1     # monomer diffusion coefficient (μm²/s)\n    diff_dimer::Float64 = 0.05      # dimer diffusion coefficient (μm²/s)\n    diff_dimer_rot::Float64 = 0.5   # dimer rotational diffusion coefficient (rad²/s)\n    k_off::Float64 = 0.2            # dimer dissociation rate (s⁻¹)\n    r_react::Float64 = 0.01         # reaction radius (μm)\n    d_dimer::Float64 = 0.05         # monomer separation in dimer (μm)\n    dt::Float64 = 0.01              # time step (s)\n    t_max::Float64 = 10.0           # total simulation time (s)\n    ndims::Int = 2                  # number of dimensions (2 or 3)\n    boundary::String = \"periodic\"   # boundary condition type (\"periodic\" or \"reflecting\")\n    camera_framerate::Float64 = 10.0 # camera frames per second (Hz)\n    camera_exposure::Float64 = 0.1   # camera exposure time per frame (s)\nend\n\nMolecular Patterns\n\nNmer2D\n\nN molecules symmetrically organized around a circle with diameter d.\n\nmutable struct Nmer2D <: Pattern2D\n    n::Int               # Number of molecules in the pattern\n    d::Float64           # Diameter of the circle in microns\n    x::Vector{Float64}   # X positions of molecules in microns\n    y::Vector{Float64}   # Y positions of molecules in microns\nend\n\nLine2D\n\nPoints with uniform random distribution between two endpoints.\n\nmutable struct Line2D <: Pattern2D\n    n::Int                # Number of molecules in the pattern\n    x::Vector{Float64}    # X positions of molecules in microns\n    y::Vector{Float64}    # Y positions of molecules in microns\n    λ::Float64            # Linear molecule density (molecules per micron)\n    endpoints::Vector{Tuple{Float64,Float64}}  # Vector of endpoint coordinates\nend\n\nFluorophore Models\n\nGenericFluor\n\nDefines a fluorophore with photophysical properties.\n\nstruct GenericFluor <: Molecule\n    γ::AbstractFloat     # Photon emission rate in Hz\n    q::Array{<:AbstractFloat}  # Rate matrix for state transitions\nend\n\nConstructor Examples\n\nCreating Simulation Parameters\n\n# Static SMLM with default parameters\nparams_static = StaticSMLMParams()\n\n# Custom parameters for static simulation\nparams_static = StaticSMLMParams(\n    density = 2.0,        # 2 patterns per μm²\n    σ_psf = 0.15,         # 150nm PSF width\n    nframes = 2000,       # 2000 frames\n    framerate = 20.0      # 20 fps\n)\n\n# Diffusion simulation with default parameters\nparams_diff = DiffusionSMLMParams()\n\n# Custom parameters for diffusion simulation\nparams_diff = DiffusionSMLMParams(\n    density = 0.5,        # molecules per μm²\n    box_size = 15.0,      # 15μm box size\n    diff_monomer = 0.2,   # 0.2 μm²/s diffusion coefficient\n    k_off = 0.1,          # 0.1 s⁻¹ dissociation rate\n    t_max = 20.0          # 20s simulation time\n)\n\nCreating Patterns\n\n# Create an 8-molecule pattern with 100nm diameter (default)\nnmer = Nmer2D()\n\n# Create a custom pattern with 6 molecules and 200nm diameter\nhexamer = Nmer2D(n=6, d=0.2)  # d is in microns\n\n# Create a 3D pattern\noctamer3d = Nmer3D(n=8, d=0.15)\n\n# Create a line pattern\nline = Line2D(λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])  # 5 molecules/μm\n\n# Create a 3D line pattern\nline3d = Line3D(λ=8.0, endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)])\n\nCreating Fluorophore Models\n\n# Create a fluorophore with default parameters\nfluor = GenericFluor()\n\n# Create a fluorophore with custom parameters\n# γ=100,000 photons/s, k_off=10 Hz, k_on=0.1 Hz\nfluor = GenericFluor(1e5, [-10.0 10.0; 0.1 -0.1])\n\n# Create a fluorophore using the 2-state keyword constructor\nfluor = GenericFluor(photons=1e5, k_off=50.0, k_on=1e-2)\n\nCreating a Camera\n\n# IdealCamera: Poisson noise only\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\n\n# Specify field of view with an array of pixel edges\npixel_edges_x = 0.0:0.1:12.8  # 0 to 12.8μm in 0.1μm steps\npixel_edges_y = 0.0:0.1:12.8\ncamera = IdealCamera(pixel_edges_x, pixel_edges_y)\n\n# SCMOSCamera: Realistic noise model with per-pixel calibration (SMLMData 0.4+)\n# Parameters: width, height, pixel_size, readnoise\ncamera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)  # 1.6 e⁻ RMS read noise\n\n# Advanced: Specify all calibration parameters\n# offset (ADU), gain (e⁻/ADU), readnoise (e⁻ RMS), quantum efficiency (0-1)\ncamera_scmos = SCMOSCamera(\n    128, 128, 0.1;\n    offset=100.0,      # 100 ADU dark level\n    gain=0.5,          # 0.5 e⁻/ADU\n    readnoise=1.6,     # 1.6 e⁻ RMS\n    qe=0.95            # 95% quantum efficiency\n)\n\nCore Functions\n\nSimulation\n\nsimulate\n\nThe main simulation function with multiple methods for different simulation types.\n\n# Static SMLM simulation\n# First create simulation parameters\nparams = StaticSMLMParams()\n\n# Then run simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=Nmer2D(),\n    molecule=GenericFluor(),\n    camera=IdealCamera(128, 128, 0.1)\n)\n\n# Diffusion simulation\n# First create simulation parameters\nparams_diff = DiffusionSMLMParams()\n\n# Then run simulation\nsmld = simulate(\n    params_diff;\n    photons=1000.0\n)\n\nkinetic_model\n\nGenerate kinetic blinking model from existing localization data.\n\n# Example of how to call kinetic_model\n# First create or obtain the required inputs\nsmld_true = ... # Some BasicSMLD with true positions\nfluor = GenericFluor(1e5, [-10.0 10.0; 0.5 -0.5])  # Fluorophore model\nnframes = 1000    # Number of frames\nframerate = 50.0  # Frames per second\n\n# Call the function\nsmld_model = kinetic_model(\n    smld_true,     # BasicSMLD with emitter positions\n    fluor,         # Molecule with kinetic rates\n    nframes,       # Number of frames\n    framerate;     # Frames per second\n    ndatasets=1,   # Number of independent datasets\n    minphotons=50.0, # Minimum photons for detection\n    state1=:equilibrium  # Initial state sampling\n)\n\napply_noise\n\nAdd localization uncertainty to emitter positions based on photon counts.\n\n# Example usage of apply_noise\n\n# First, you need smld_model from a previous step\n# For example, from the output of kinetic_model()\n\n# For 2D emitters - add noise with 130nm PSF width\nsmld_noisy = apply_noise(smld_model, 0.13)  # 0.13 μm = 130nm PSF width\n\n# For 3D emitters - specify PSF width in each dimension\nsmld_noisy_3d = apply_noise(smld_model_3d, [0.13, 0.13, 0.39])  # [x, y, z] widths in μm\n\nImage Generation\n\ngen_images\n\nGenerate camera images from SMLD data using the specified PSF model.\n\nimages = gen_images(\n    smld::SMLD,\n    psf::AbstractPSF;\n    dataset::Int=1,                # Dataset number to use from SMLD\n    frames=nothing,                # Specific frames to generate (default: all frames)\n    support=Inf,                   # PSF support region size (see details below)\n    sampling=2,                    # Supersampling factor for PSF integration\n    threaded=true,                 # Enable multithreading\n    bg=0.0,                        # Background signal level (photons per pixel)\n    poisson_noise=false,           # Apply Poisson noise only (simple shot noise)\n    camera_noise=false             # Apply full camera noise model (requires SCMOSCamera)\n                                   # - For SCMOSCamera: QE, Poisson, read noise, gain, offset\n                                   # - For IdealCamera: ignored (use poisson_noise instead)\n)\n\n# The support parameter controls PSF computation region:\n# 1. Inf (default): Compute PSF over entire image (most accurate but slowest)\nsupport=Inf\n\n# 2. Real number: Use circular region with given radius around each emitter\n# Typically 3-5× the PSF width is sufficient for accuracy with better performance\nsupport=1.0  # 1.0 µm radius around each emitter\n\n# 3. Tuple (xmin, xmax, ymin, ymax): Explicit region in microns\nsupport=(4.0, 6.0, 4.0, 6.0)  # Only compute PSF within this region\n\n# Example: sCMOS camera with realistic noise\ncamera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)\nsmld = BasicSMLD(emitters, camera_scmos, n_frames, n_datasets)\nimages_scmos = gen_images(smld, psf, bg=10.0, camera_noise=true)\n# Applies: QE → Poisson → read noise → gain → offset\n\n# Example: IdealCamera with Poisson noise only\ncamera_ideal = IdealCamera(128, 128, 0.1)\nsmld = BasicSMLD(emitters, camera_ideal, n_frames, n_datasets)\nimages_poisson = gen_images(smld, psf, bg=10.0, poisson_noise=true)\n\ngen_image\n\nGenerate a single frame camera image.\n\n# Example of generating a single frame image\n\n# First, define variables\nsmld = ... # Your SMLD data\npsf = GaussianPSF(0.15)  # PSF model with 150nm width\nframe_number = 10  # The frame you want to generate\n\n# Generate image for a specific frame\nsingle_frame = gen_image(\n    smld,          # SMLD data \n    psf,           # PSF model\n    frame_number;  # Frame to generate\n    support=1.0,   # Same keyword arguments as gen_images\n    bg=5.0,\n    poisson_noise=true\n)\n\nAnalysis Functions\n\nDiffusion Analysis\n\n# Example usage of diffusion analysis functions\n\n# First, run a diffusion simulation\nparams = DiffusionSMLMParams()\nsmld = simulate(params)\n\n# Extract dimers from diffusion simulation\ndimer_smld = get_dimers(smld)\n\n# Extract monomers\nmonomer_smld = get_monomers(smld)\n\n# Analyze dimer formation over time\nframes, fractions = analyze_dimer_fraction(smld)\n\n# Analyze average dimer lifetime\nlifetime = analyze_dimer_lifetime(smld)\n\n# Track state changes over time\nstate_history = track_state_changes(smld)\n\nTrack Utilities\n\n# Example usage of track utilities\n\n# First, run a simulation\nparams = StaticSMLMParams()\nsmld_true, smld_model, smld_noisy = simulate(params)\n\n# Specify a track ID to extract\ntrack_id = 1  # ID of the track to extract\n\n# Get a specific track by ID\ntrack_smld = get_track(smld_noisy, track_id)\n\n# Get number of unique tracks\nn_tracks = get_num_tracks(smld_noisy)\n\n# Get all tracks as separate SMLDs\ntrack_smlds = get_tracks(smld_noisy)\n\nPattern Manipulation\n\n# Example usage of pattern manipulation\n\n# Create patterns\npattern2d = Nmer2D(n=6, d=0.2)\npattern3d = Nmer3D(n=8, d=0.15)\n\n# Rotate a 2D pattern by 45 degrees\nrotate!(pattern2d, π/4) \n\n# Rotate a 3D pattern with Euler angles (ZYZ convention)\nrotate!(pattern3d, π/4, π/6, π/3)  # α, β, γ angles\n\n# Rotate a 3D pattern with a rotation matrix\nθ = π/2 # 90 degrees\nR = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]  # Z-axis rotation\nrotate!(pattern3d, R)\n\n# Generate random pattern distribution in a field\nfield_x = 10.0 # μm\nfield_y = 10.0 # μm\ndensity = 1.0  # patterns per μm²\n\n# Get coordinates for 2D distribution\nx, y = uniform2D(density, pattern2d, field_x, field_y)\n\n# Get coordinates for 3D distribution\nx, y, z = uniform3D(density, pattern3d, field_x, field_y, zrange=[-2.0, 2.0])\n\nCommon Workflows\n\nStatic SMLM Simulation Workflow\n\nDefine simulation parameters\nCreate a pattern (or use default)\nDefine a fluorophore model (or use default)\nRun simulation to get true positions, kinetic model, and noisy localizations\nGenerate microscope images or analyze the data\n\n# 1. Define parameters\nparams = StaticSMLMParams(\n    density = 1.0,\n    σ_psf = 0.13,\n    nframes = 1000\n)\n\n# 2. Create a pattern\npattern = Nmer2D(n=6, d=0.2)  # hexamer with 200nm diameter\n\n# 3. Define fluorophore model\nfluor = GenericFluor(photons=1e5, k_off=50.0, k_on=1e-2)\n\n# 4. Run simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=pattern,\n    molecule=fluor\n)\n\n# 5. Create microscope images with efficient PSF support\npsf = GaussianPSF(0.15)  # 150nm PSF width\nimages = gen_images(smld_model, psf; \n    support=1.0,         # 1.0 μm radius around each emitter\n    poisson_noise=true   # Add realistic photon counting noise\n)\n\nDiffusion Simulation Workflow\n\nDefine diffusion parameters\nRun simulation to get emitter trajectories\nAnalyze the diffusion and interaction dynamics\nGenerate microscope images\n\n# 1. Define parameters\nparams = DiffusionSMLMParams(\n    density = 0.5,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    t_max = 10.0          # s\n)\n\n# 2. Run simulation\nsmld = simulate(params)\n\n# 3. Analyze the results\ndimer_smld = get_dimers(smld)\nframes, fractions = analyze_dimer_fraction(smld)\n\n# 4. Generate microscope images with realistic sCMOS noise\n# Create sCMOS camera matching simulation box\nn_pixels = Int(ceil(params.box_size / 0.1))  # 0.1 μm pixels\ncamera_scmos = SCMOSCamera(n_pixels, n_pixels, 0.1, 1.6)\nsmld_cam = BasicSMLD(smld.emitters, camera_scmos, smld.n_frames, 1)\n\npsf = GaussianPSF(0.15)  # 150nm PSF width\nimages = gen_images(smld_cam, psf;\n    support=1.0,         # 1.0 μm PSF support radius (faster)\n    bg=5.0,              # Background photons per pixel\n    camera_noise=true    # Full sCMOS noise model (QE, Poisson, read noise, gain, offset)\n)\n\nComplete Examples\n\nStatic SMLM with Image Generation\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Define a camera and simulation parameters\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\nparams = StaticSMLMParams(density=1.0, σ_psf=0.13, nframes=1000) \n\n# Run simulation for an 8-molecule ring pattern\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=Nmer2D(n=8, d=0.1),  # 100nm diameter ring\n    molecule=GenericFluor(1e5, [-10.0 10.0; 0.5 -0.5]),  # γ=100,000, k_off=10, k_on=0.5\n    camera=camera\n)\n\n# Create a PSF model\npsf = GaussianPSF(0.15)  # 150nm PSF width\n\n# Generate microscope images with finite PSF support\nimages = gen_images(smld_model, psf;\n    support=1.0,         # 1.0 μm PSF support radius (faster than Inf)\n    bg=5.0,              # 5 background photons per pixel\n    poisson_noise=true   # Add realistic photon counting noise\n)\n\nprintln(\"Generated $(length(smld_noisy.emitters)) localizations and $(size(images,3)) images.\")\n\nDiffusion with Dimer Analysis\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Set diffusion simulation parameters\nparams = DiffusionSMLMParams(\n    density = 0.5,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    t_max = 10.0,         # s\n    boundary = \"reflecting\"  # Use reflecting boundaries\n)\n\n# Run diffusion simulation\nsmld = simulate(params)\n\n# Analyze dimer formation\nframes, dimer_fraction = analyze_dimer_fraction(smld)\navg_lifetime = analyze_dimer_lifetime(smld)\n\n# Generate microscope images with finite PSF support\npsf = GaussianPSF(0.15)  # 150nm PSF width\nimages = gen_images(smld, psf; \n    support=1.0,         # 1.0 μm PSF support radius (faster)\n    bg=2.0,              # Background photons per pixel\n    poisson_noise=true   # Add realistic photon counting noise\n)\n\nprintln(\"Simulation complete with $(length(smld.emitters)) emitters\")\nprintln(\"Average dimer fraction: $(mean(dimer_fraction))\")\nprintln(\"Average dimer lifetime: $(avg_lifetime) seconds\")\n\nCustom Pattern with 3D Simulation\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Define a custom 3D pattern: two rings at different z-positions\nmutable struct DoubleRing3D <: Pattern3D\n    n::Int\n    d1::Float64\n    d2::Float64\n    z1::Float64\n    z2::Float64\n    x::Vector{Float64}\n    y::Vector{Float64}\n    z::Vector{Float64}\nend\n\nfunction DoubleRing3D(; n=8, d1=0.1, d2=0.2, z1=-0.2, z2=0.2)\n    total_n = 2*n\n    x = zeros(total_n)\n    y = zeros(total_n)\n    z = zeros(total_n)\n    \n    # First ring (bottom)\n    for i = 1:n\n        θ = 2π * (i-1) / n\n        x[i] = d1/2 * cos(θ)\n        y[i] = d1/2 * sin(θ)\n        z[i] = z1\n    end\n    \n    # Second ring (top)\n    for i = 1:n\n        θ = 2π * (i-1) / n + π/n  # Offset angle for second ring\n        x[n+i] = d2/2 * cos(θ)\n        y[n+i] = d2/2 * sin(θ)\n        z[n+i] = z2\n    end\n    \n    return DoubleRing3D(n, d1, d2, z1, z2, x, y, z)\nend\n\n# Create camera and parameters\ncamera = IdealCamera(128, 128, 0.1)\nparams = StaticSMLMParams(\n    density = 0.5,\n    σ_psf = 0.13,\n    nframes = 2000,\n    ndims = 3,\n    zrange = [-1.0, 1.0]\n)\n\n# Create custom pattern\ndouble_ring = DoubleRing3D(n=6, d1=0.15, d2=0.3, z1=-0.3, z2=0.3)\n\n# Run simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=double_ring,\n    camera=camera\n)\n\n# Generate images with a 3D astigmatic PSF and finite support\n# Create a PSF with astigmatism using Zernike coefficients\nusing MicroscopePSFs\nzc = ZernikeCoefficients(15)\nzc.phase[6] = 0.5  # Add vertical astigmatism\npsf_scalar = ScalarPSF(1.4, 0.532, 1.52; zernike_coeffs=zc)\n\n# Create SplinePSF for speed\nxy_sampling, z_sampling = 0.05, 0.1\nx_range = y_range = -1.0:xy_sampling:1.0\nz_range = -1.0:z_sampling:1.0\npsf_spline = SplinePSF(psf_scalar, x_range, y_range, z_range)\n\n# Generate images using the spline PSF with finite support\nimages = gen_images(smld_model, psf_spline; \n    support=0.5,         # 0.5 μm PSF support radius for performance\n    bg=5.0,              # Background photons per pixel\n    poisson_noise=true   # Add realistic photon counting noise\n)\n\nprintln(\"Generated $(length(smld_noisy.emitters)) localizations in 3D\")\n\n\n\napi() returns this documentation as a plain String.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.simulate-Tuple{AbstractSim}","page":"API Reference","title":"SMLMSim.simulate","text":"simulate(sim::AbstractSim; kwargs...)\n\nGeneric interface for all simulation types. Dispatches to the appropriate method based on the concrete simulation type.\n\nArguments\n\nsim::AbstractSim: The simulation configuration object\nkwargs...: Additional keyword arguments specific to the simulation type\n\nReturns\n\nThe result of the specific simulation method\n\nExample\n\n# Create a static SMLM simulation configuration\nparams = StaticSMLMParams(\n    density = 1.0,        # Changed from ρ to density\n    σ_psf = 0.13\n)\n\n# Run the simulation\nresults = simulate(params)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core","page":"API Reference","title":"SMLMSim.Core","text":"Core\n\nCore module with shared utilities for SMLM simulation.\n\nThis module contains fundamental components that can be used across different simulation types (static, diffusion, etc.) including:\n\nAbstract types for simulation\nMolecule and pattern definitions\nCTMC (Continuous Time Markov Chain) for stochastic state transitions\nPhotophysics modeling for blinking kinetics and detection\n\nUsage\n\nusing SMLMSim.Core\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMSim.Core.AbstractSim","page":"API Reference","title":"SMLMSim.Core.AbstractSim","text":"AbstractSim\n\nAbstract type for all simulation types in SMLMSim. Concrete subtypes should implement their own simulate methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.CTMC","page":"API Reference","title":"SMLMSim.Core.CTMC","text":"CTMC{T<:AbstractFloat, U<:Int}\n\nA Continuous Time Markov Chain representation storing the full trajectory of state transitions.\n\nFields\n\nsimulation_time::T: Total simulation time span\ntransition_times::Vector{T}: Time points at which state changes occurred, starting at 0.0 \nstates::Vector{U}: Sequence of states entered at each transition time, starting with initial state\n\nType Parameters\n\nT: Floating point type for time values\nU: Integer type for state indices\n\nNote\n\nThe states and transition_times vectors have the same length, with each entry in states[i] representing the state entered at time transition_times[i]. The system remains in states[i]  until time transition_times[i+1].\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.CTMC-Union{Tuple{T}, Tuple{Array{T}, T, Int64}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.CTMC","text":"CTMC(q::Array{T}, simulation_time::T, state1::Int) where {T<:AbstractFloat}\n\nConstruct a Continuous Time Markov Chain simulation from a rate matrix.\n\nArguments\n\nq::Array{T}: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i\nsimulation_time::T: Total time to simulate\nstate1::Int: Initial state\n\nReturns\n\nCTMC{T,Int}: Simulated CTMC with transition times and states\n\nDetails\n\nSimulates a CTMC using the Gillespie algorithm:\n\nStart in state1 at time 0\nFor current state i:\nCalculate total exit rate ktot = Σj q[i,j]\nSample time until next transition from Exp(k_tot)\nSample next state j with probability q[i,j]/k_tot\nRepeat until exceeding simulation_time\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.GenericFluor","page":"API Reference","title":"SMLMSim.Core.GenericFluor","text":"GenericFluor <: Molecule\n\nDefines a fluorophore with photophysical properties.\n\nFields\n\nγ::AbstractFloat: Photon emission rate in Hz. Default: 1e5\nq::Array{<:AbstractFloat}: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i. Default: standard 2-state model with on->off rate of 50Hz and off->on rate of 1e-2Hz\n\nExamples\n\n# Create a fluorophore with default parameters (using the 2-state keyword constructor)\nfluor = GenericFluor()\n\n# Create a fluorophore with custom parameters using the positional constructor\nfluor = GenericFluor(1e5, [-50.0 50.0; 1e-2 -1e-2])\n\n# Create a fluorophore using the 2-state keyword constructor\nfluor = GenericFluor(; photons=1e5, k_off=10.0, k_on=1e-1)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.GenericFluor-Tuple{}","page":"API Reference","title":"SMLMSim.Core.GenericFluor","text":"GenericFluor(; photons::AbstractFloat=1e5, k_off::AbstractFloat=50.0, k_on::AbstractFloat=1e-2)\n\nCreate a simple two-state (on/off) fluorophore with specified parameters.\n\nArguments\n\nphotons::AbstractFloat: Photon emission rate in Hz\nk_off::AbstractFloat: Off-switching rate (on→off) in Hz\nk_on::AbstractFloat: On-switching rate (off→on) in Hz\n\nDetails\n\nCreates a fluorophore with a 2-state model and the specified rates. State 1 is the on (bright) state, and state 2 is the off (dark) state. The rate matrix is constructed as: q = [-koff koff; kon -kon]\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.Line2D","page":"API Reference","title":"SMLMSim.Core.Line2D","text":"Line2D <: Pattern2D\n\nPoints with uniform random distribution between two endpoints.\n\nFields\n\nλ::Float64: Linear molecule density (molecules per micron)\nendpoints::Vector{Tuple{Float64,Float64}}: Vector of endpoint coordinates\nn::Int: Number of molecules in the pattern\nx::Vector{Float64}: X positions of molecules in microns\ny::Vector{Float64}: Y positions of molecules in microns\n\nExamples\n\n# Create a line with default parameters\nline = Line2D()\n\n# Create a custom line\nline = Line2D(; λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Line3D","page":"API Reference","title":"SMLMSim.Core.Line3D","text":"Line3D <: Pattern3D\n\nPoints with uniform random distribution between two 3D endpoints.\n\nFields\n\nλ::Float64: Linear molecule density (molecules per micron)\nendpoints::Vector{Tuple{Float64,Float64,Float64}}: Vector of 3D endpoint coordinates\nn::Int: Number of molecules in the pattern\nx::Vector{Float64}: X positions of molecules in microns\ny::Vector{Float64}: Y positions of molecules in microns\nz::Vector{Float64}: Z positions of molecules in microns\n\nExamples\n\n# Create a line with default parameters\nline = Line3D()\n\n# Create a custom 3D line\nline = Line3D(; λ=5.0, endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)])\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Molecule","page":"API Reference","title":"SMLMSim.Core.Molecule","text":"Molecule\n\nAbstract type for representing photophysical properties of a molecule.\n\nThis is the most general type of luminescent or scattering single molecule. Inherited types will define the properties of specific classes of molecules.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Nmer2D","page":"API Reference","title":"SMLMSim.Core.Nmer2D","text":"Nmer2D <: Pattern2D\n\nN molecules symmetrically organized around a circle with diameter d.\n\nFields\n\nn::Int: Number of molecules in the pattern\nd::Float64: Diameter of the circle in microns\nx::Vector{Float64}: X positions of molecules in microns\ny::Vector{Float64}: Y positions of molecules in microns\n\nExamples\n\n# Create an 8-molecule pattern with 100nm diameter\nnmer = Nmer2D()\n\n# Create a custom pattern with 6 molecules and 200nm diameter\nnmer = Nmer2D(; n=6, d=0.2)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Nmer3D","page":"API Reference","title":"SMLMSim.Core.Nmer3D","text":"Nmer3D <: Pattern3D\n\nN molecules symmetrically organized around a circle with diameter d at z=0.\n\nFields\n\nn::Int: Number of molecules in the pattern\nd::Float64: Diameter of the circle in microns\nx::Vector{Float64}: X positions of molecules in microns\ny::Vector{Float64}: Y positions of molecules in microns\nz::Vector{Float64}: Z positions of molecules in microns\n\nExamples\n\n# Create an 8-molecule pattern with 100nm diameter\nnmer = Nmer3D()\n\n# Create a custom pattern with 6 molecules and 200nm diameter\nnmer = Nmer3D(; n=6, d=0.2)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Pattern","page":"API Reference","title":"SMLMSim.Core.Pattern","text":"Pattern\n\nAbstract type for all molecular spatial patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Pattern2D","page":"API Reference","title":"SMLMSim.Core.Pattern2D","text":"Pattern2D <: Pattern\n\nAbstract type for 2D molecular spatial patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.Pattern3D","page":"API Reference","title":"SMLMSim.Core.Pattern3D","text":"Pattern3D <: Pattern\n\nAbstract type for 3D molecular spatial patterns.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.SMLMSimParams","page":"API Reference","title":"SMLMSim.Core.SMLMSimParams","text":"SMLMSimParams <: AbstractSim\n\nAbstract type for all SMLM simulation parameter types. Provides a common parent for different types of SMLM simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.Core.compute_equilibrium_distribution-Tuple{Matrix{<:AbstractFloat}}","page":"API Reference","title":"SMLMSim.Core.compute_equilibrium_distribution","text":"compute_equilibrium_distribution(q::Matrix{<:AbstractFloat})\n\nCalculate the equilibrium probability distribution for a CTMC rate matrix.\n\nArguments\n\nq::Matrix{<:AbstractFloat}: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i\n\nReturns\n\nVector{Float64}: Equilibrium probabilities for each state\n\nDetails\n\nFor a rate matrix Q, the equilibrium distribution π satisfies π·Q = 0 subject to Σπ = 1. This function solves the linear system directly to find the equilibrium distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.get_next-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.get_next","text":"get_next(ctmc::CTMC, t::AbstractFloat)\n\nGet the next state transition after a specific time point.\n\nArguments\n\nctmc::CTMC: The CTMC to query\nt::AbstractFloat: Current time point\n\nReturns\n\nTuple{Int,AbstractFloat}: (nextstate, transitiontime)\n\nNote\n\nReturns the next state that will be entered and when it will be entered, searching from the current time point forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.get_num_tracks-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.Core.get_num_tracks","text":"get_num_tracks(smld::BasicSMLD)\n\nReturn the number of unique tracks (based on track_id) in the SMLD.\n\nArguments\n\nsmld::BasicSMLD: The SMLD to analyze\n\nReturns\n\nInt: Number of unique track IDs\n\nExample\n\n# Get the number of tracks\nn_tracks = get_num_tracks(smld)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.get_state-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.get_state","text":"get_state(ctmc::CTMC, t::AbstractFloat)\n\nGet the state of the CTMC at a specific time point.\n\nArguments\n\nctmc::CTMC: The CTMC to query\nt::AbstractFloat: Time point of interest\n\nReturns\n\nInt: State of the chain at time t\n\nNote\n\nSearches through transition times to find the state active at time t. Returns the state that was entered at the last transition before t.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.get_track-Tuple{BasicSMLD, Int64}","page":"API Reference","title":"SMLMSim.Core.get_track","text":"get_track(smld::BasicSMLD, id::Int)\n\nReturn a new SMLD containing only emitters with the specified track_id.\n\nArguments\n\nsmld::BasicSMLD: The original SMLD\nid::Int: Track ID to filter by\n\nReturns\n\nBasicSMLD: New SMLD containing only emitters from the specified track\n\nExample\n\n# Get all emitters belonging to track 5\ntrack_smld = get_track(smld, 5)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.get_tracks-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.Core.get_tracks","text":"get_tracks(smld::BasicSMLD)\n\nReturn a vector of SMLD objects, one for each unique track (based on track_id).\n\nArguments\n\nsmld::BasicSMLD: The original SMLD\n\nReturns\n\nVector{BasicSMLD}: Vector of SMLD objects, one per track\n\nExample\n\n# Get all tracks as separate SMLD objects\ntrack_smlds = get_tracks(smld)\n\n# Access the first track\nfirst_track = track_smlds[1]\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.intensity_trace-Tuple{GenericFluor, Int64, Real}","page":"API Reference","title":"SMLMSim.Core.intensity_trace","text":"intensity_trace(f::GenericFluor, nframes::Int, framerate::Real; state1=1)\n\nCalculate a fluorescence intensity trace by integrating emission during fluorescent state occupancy.\n\nArguments\n\nf::GenericFluor: Fluorophore model containing transition rates (q) and emission rate (γ)\nnframes::Int: Number of frames to simulate\nframerate::Real: Frame rate in Hz\nstate1::Int=1: Initial state (default: 1 for fluorescent state)\n\nReturns\n\nVector{Float64}: Integrated photon counts for each frame\n\nDetails\n\nFor each frame:\n\nDetermines state occupancy using CTMC\nIntegrates emission (rate f.γ) during fluorescent state periods\nAccumulates photons within frame exposure time (1/framerate)\n\nExample\n\nfluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])\nphotons = intensity_trace(fluor, 1000, 10.0)\n\nNote\n\nState 1 is assumed to be the fluorescent state\nEmission only occurs in state 1 with rate f.γ\nFrame exposure is assumed to be 1/framerate (100% duty cycle)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.kinetic_model-Tuple{BasicSMLD, Molecule, Int64, Real}","page":"API Reference","title":"SMLMSim.Core.kinetic_model","text":"kinetic_model(smld::BasicSMLD, f::Molecule, nframes::Int, framerate::Real;\n             ndatasets::Int=1, minphotons=50.0, state1::Int=2)\n\nGenerate kinetic blinking model from existing localization data.\n\nArguments\n\nsmld::BasicSMLD: Input SMLD containing true emitter positions\nf::Molecule: Fluorophore model with kinetic rates\nnframes::Int: Number of frames to simulate\nframerate::Real: Frame rate in Hz\nndatasets::Int=1: Number of independent datasets to generate\nminphotons::Float64=50.0: Minimum photons for detection\nstate1::Union{Int, Symbol}=:equilibrium: Initial state specification:\n::Int: Specific state to start in (1=on, 2=off typically)\n:equilibrium: Sample from equilibrium distribution (default)\n\nReturns\n\nBasicSMLD: New SMLD with simulated blinking kinetics\n\nDetails\n\nFor each unique position in the input SMLD:\n\nSimulates fluorophore blinking using the kinetic model\nCreates emitters for frames where photon count exceeds threshold\nPreserves track_id for linking emitters from same position\nMaintains camera and extends metadata from input SMLD\n\nExample\n\ncamera = IdealCamera(1:128, 1:128, 0.1)\npattern = Nmer2D()\nsmld_true, _, _ = simulate(pattern=pattern, camera=camera)\n\n# Add blinking kinetics\nfluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])\nsmld_model = kinetic_model(smld_true, fluor, 1000, 10.0)\n\nNote\n\nThe emitter type (2D/3D) is automatically determined from the input SMLD. Position uncertainties are initialized to 0 and can be set using the apply_noise() function.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern2D, T}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.rotate!","text":"rotate!(p::Pattern2D, θ::Float64)\n\nRotate a 2D pattern by angle θ (in radians).\n\nArguments\n\np::Pattern2D: Pattern to rotate\nθ::Float64: Rotation angle in radians\n\nExample\n\nnmer = Nmer2D()\nrotate!(nmer, π/4)  # Rotate 45 degrees\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, Matrix{T}}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.rotate!","text":"rotate!(p::Pattern3D, R::Matrix{Float64})\n\nRotate a 3D pattern by rotation matrix R.\n\nArguments\n\np::Pattern3D: Pattern to rotate\nR::Matrix{Float64}: 3x3 rotation matrix\n\nExample\n\nnmer = Nmer3D()\n# Create a rotation matrix for 90 degrees around z-axis\nθ = π/2\nR = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]\nrotate!(nmer, R)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, T, T, T}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.Core.rotate!","text":"rotate!(p::Pattern3D, α::Float64, β::Float64, γ::Float64)\n\nRotate a 3D pattern by Euler angles α, β, γ (in radians). Uses ZYZ convention.\n\nArguments\n\np::Pattern3D: Pattern to rotate\nα::Float64: First rotation angle (around Z axis)\nβ::Float64: Second rotation angle (around Y' axis)\nγ::Float64: Third rotation angle (around Z'' axis)\n\nExample\n\nnmer = Nmer3D()\nrotate!(nmer, π/4, π/6, π/3)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.sample_discrete-Tuple{Vector{<:AbstractFloat}}","page":"API Reference","title":"SMLMSim.Core.sample_discrete","text":"sample_discrete(p::Vector{<:AbstractFloat})\n\nSample from a discrete probability distribution.\n\nArguments\n\np::Vector{<:AbstractFloat}: Probability distribution\n\nReturns\n\nInt: Sampled state index\n\nDetails\n\nSamples a state index i with probability p[i] using the inverse CDF method.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.sample_discrete_with_probs-Tuple{Any, Any}","page":"API Reference","title":"SMLMSim.Core.sample_discrete_with_probs","text":"sample_discrete_with_probs(indices, probs)\n\nSample a discrete value from indices with corresponding probabilities.\n\nArguments\n\nindices::Vector{Int}: Vector of possible indices to sample\nprobs::Vector{<:AbstractFloat}: Corresponding probabilities\n\nReturns\n\nInt: Sampled index\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.uniform2D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern2D, T2, T3}} where {T1<:AbstractFloat, T2<:AbstractFloat, T3<:AbstractFloat}","page":"API Reference","title":"SMLMSim.Core.uniform2D","text":"uniform2D(ρ::Float64, p::Pattern2D, field_x::Float64, field_y::Float64)\n\nCreate coordinate arrays for randomly placed and rotated 2D patterns.\n\nArguments\n\nρ::Float64: Pattern density (patterns per square micron)\np::Pattern2D: Pattern to replicate\nfield_x::Float64: Field width in microns\nfield_y::Float64: Field height in microns\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: (x, y) coordinates in microns\n\nExample\n\n# Generate coordinates for randomly placed Nmer2D patterns\nnmer = Nmer2D(; n=6, d=0.2)\nx, y = uniform2D(1.0, nmer, 10.0, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.Core.uniform3D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern3D, T2, T3}} where {T1<:AbstractFloat, T2<:AbstractFloat, T3<:AbstractFloat}","page":"API Reference","title":"SMLMSim.Core.uniform3D","text":"uniform3D(ρ::Float64, p::Pattern3D, field_x::Float64, field_y::Float64; \n         zrange::Vector{Float64}=[-1.0, 1.0])\n\nCreate coordinate arrays for randomly placed and rotated 3D patterns.\n\nArguments\n\nρ::Float64: Pattern density (patterns per square micron)\np::Pattern3D: Pattern to replicate\nfield_x::Float64: Field width in microns\nfield_y::Float64: Field height in microns\nzrange::Vector{Float64}=[-1.0, 1.0]: [minz, maxz] range in microns\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}: (x, y, z) coordinates\n\nExample\n\n# Generate coordinates for randomly placed Nmer3D patterns\nnmer = Nmer3D(; n=6, d=0.2)\nx, y, z = uniform3D(1.0, nmer, 10.0, 10.0; zrange=[-2.0, 2.0])\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.StaticSMLM","page":"API Reference","title":"SMLMSim.StaticSMLM","text":"StaticSMLM\n\nModule for simulating static (non-diffusing) SMLM data with blinking kinetics.\n\nThis module provides functionality for:\n\nGenerating spatial distributions of emitters based on patterns\nSimulating fluorophore blinking based on stochastic kinetic models\nAdding realistic localization uncertainties\nCreating complete SMLM datasets\n\nUsage\n\nusing SMLMSim.StaticSMLM\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMSim.StaticSMLM.StaticSMLMParams","page":"API Reference","title":"SMLMSim.StaticSMLM.StaticSMLMParams","text":"StaticSMLMParams <: SMLMSimParams\n\nParameters for static SMLM simulation.\n\nFields\n\ndensity::Float64: density in particles per square micron\nσ_psf::Float64: PSF width in microns\nminphotons::Int: minimum photons for detection\nndatasets::Int: number of datasets to simulate\nnframes::Int: number of frames per dataset\nframerate::Float64: frames per second\nndims::Int: dimensionality (2 or 3)\nzrange::Vector{Float64}: axial range for 3D simulations [minz, maxz]\n\nExamples\n\n# Default parameters\nparams = StaticSMLMParams()\n\n# Custom parameters\nparams = StaticSMLMParams(\n    density = 2.0,              # 2 particles per μm²\n    σ_psf = 0.15,         # 150nm PSF width\n    minphotons = 100,     # minimum photons for detection\n    ndatasets = 5,        # 5 independent datasets\n    nframes = 2000,       # 2000 frames per dataset\n    framerate = 100.0,    # 100 frames per second\n    ndims = 3,            # 3D simulation\n    zrange = [-2.0, 2.0]  # 4μm axial range\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.StaticSMLM.add_coordinate_noise-Tuple{Emitter2DFit, AbstractFloat}","page":"API Reference","title":"SMLMSim.StaticSMLM.add_coordinate_noise","text":"add_coordinate_noise(emitter, σ)\n\nHelper function to add position noise to an emitter with appropriate uncertainty. Returns new coordinate values and uncertainty values.\n\nFor 2D emitters, σ is a scalar. For 3D emitters, σ is a 3-element vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, AbstractFloat}","page":"API Reference","title":"SMLMSim.StaticSMLM.apply_noise","text":"apply_noise(smld::BasicSMLD, σ_psf::AbstractFloat)\n\nAdd localization uncertainty to 2D emitter positions based on photon counts.\n\nArguments\n\nsmld::BasicSMLD: Input SMLD containing 2D emitters\nσ_psf::AbstractFloat: PSF width in microns\n\nReturns\n\nBasicSMLD: New SMLD with noisy positions and updated uncertainties\n\nExample\n\n# Then add localization noise with specific PSF width\nsmld_noisy = apply_noise(smld_model, 0.13)  # 130nm PSF width\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, Vector{<:AbstractFloat}}","page":"API Reference","title":"SMLMSim.StaticSMLM.apply_noise","text":"apply_noise(smld::BasicSMLD, σ_psf::Vector{<:AbstractFloat})\n\nAdd localization uncertainty to 3D emitter positions based on photon counts.\n\nArguments\n\nsmld::BasicSMLD: Input SMLD containing 3D emitters\nσ_psf::Vector{<:AbstractFloat}: PSF widths [σx, σy, σz] in microns\n\nReturns\n\nBasicSMLD: New SMLD with noisy positions and updated uncertainties\n\nExample\n\n# Then add localization noise with specific PSF widths\nσ_psf = [0.13, 0.13, 0.39]  # 130nm lateral, 390nm axial\nsmld_noisy = apply_noise(smld_model, σ_psf)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.simulate-Tuple{StaticSMLMParams}","page":"API Reference","title":"SMLMSim.simulate","text":"simulate(params::StaticSMLMParams; \n         starting_conditions::Union{Nothing, SMLD, Vector{<:AbstractEmitter}}=nothing,\n         pattern::Pattern=nothing,\n         molecule::Molecule=GenericFluor(photons=1e4, k_off=50.0, k_on=1e-2),\n         camera::AbstractCamera=IdealCamera(1:128, 1:128, 0.1))\n\nGenerate simulated static SMLM data with realistic blinking kinetics and localization uncertainty.\n\nArguments\n\nparams::StaticSMLMParams: Simulation parameters\nstarting_conditions::Union{Nothing, SMLD, Vector{<:AbstractEmitter}}: Optional starting conditions instead of generating patterns\npattern::Pattern: Pattern to use (default depends on params.ndims)\nmolecule::Molecule: Fluorophore model for blinking simulation\ncamera::AbstractCamera: Camera model for detection simulation\n\nReturns\n\nTuple{BasicSMLD, BasicSMLD, BasicSMLD}: (truepositions, modelkinetics, noisy_data)\ntrue_positions: Ground truth emitter positions\nmodel_kinetics: Positions with simulated blinking\nnoisy_data: Positions with blinking and localization uncertainty\n\nExample\n\n# Create parameters\nparams = StaticSMLMParams(\n    density = 2.0,              # 2 patterns per μm²\n    σ_psf = 0.15,         # 150nm PSF width\n    minphotons = 100,     # 100 photons for detection\n    ndatasets = 5,        # 5 independent datasets\n    nframes = 2000,       # 2000 frames\n    framerate = 100.0     # 100 frames per second\n)\n\n# Run simulation with Nmer pattern\npattern = Nmer3D(n=6, d=0.2)\nsmld_true, smld_model, smld_noisy = simulate(params; pattern=pattern)\n\n# Run with custom starting conditions\ncustom_emitters = [\n    Emitter2DFit{Float64}(x, y, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0; track_id=i)\n    for (i, (x, y)) in enumerate(zip(rand(10), rand(10)))\n]\nsmld_true, smld_model, smld_noisy = simulate(params; starting_conditions=custom_emitters)\n\nNote\n\nThe params.σ_psf value is used directly for lateral uncertainty (σx, σy) in both 2D and 3D.\nFor 3D simulations, the axial uncertainty (σz) is scaled by a factor of 3 (i.e., σz = 3 * σ_psf).\nIf starting_conditions is provided, it will be used instead of generating patterns.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion","page":"API Reference","title":"SMLMSim.InteractionDiffusion","text":"InteractionDiffusion\n\nThis module provides simulation tools for diffusion and interaction between particles.\n\nOverview\n\nSimulates diffusion and interaction dynamics between particles in 2D/3D space. Includes functionality for generating microscope images, analyzing dimers, and visualizing particle dynamics.\n\nComponents\n\nAbstract and concrete emitter types (AbstractDiffusingEmitter, DiffusingEmitter2D, DiffusingEmitter3D)\nSmoluchowski dynamics simulation\nAnalysis tools for dimers and state transitions\nSMLD conversion utilities\n\nExamples\n\n# Set up simulation parameters\nparams = DiffusionSMLMParams(\n    density = 0.5,            # molecules per μm²\n    box_size = 10.0,          # μm\n    diff_monomer = 0.1,       # μm²/s\n    diff_dimer = 0.05,        # μm²/s\n    k_off = 0.2,              # s⁻¹\n    r_react = 0.01,           # μm\n    d_dimer = 0.05,           # μm\n    dt = 0.01,                # s\n    t_max = 10.0,             # s\n    camera_framerate = 20.0,  # fps\n    camera_exposure = 0.04    # s\n)\n\n# Run simulation - returns a single SMLD with all emitters\nsmld = simulate(params)\n\n# Generate images for microscopy\npsf = GaussianPSF(0.15)  # 150nm PSF width\nimages = gen_images(psf, smld)\n\n# Analyze results\ndimer_smld = get_dimers(smld)\nframes, dimer_fractions = analyze_dimer_fraction(smld)\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter","page":"API Reference","title":"SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter","text":"AbstractDiffusingEmitter <: AbstractEmitter\n\nAbstract type for all diffusing emitters to enable dispatch-based operations. This provides a common parent for 2D and 3D diffusing emitters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.InteractionDiffusion.DiffusingEmitter2D","page":"API Reference","title":"SMLMSim.InteractionDiffusion.DiffusingEmitter2D","text":"DiffusingEmitter2D{T<:AbstractFloat} <: AbstractDiffusingEmitter\n\nA 2D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nphotons::T: number of photons emitted\ntimestamp::T: actual simulation time in seconds\nframe::Int: camera frame number based on framerate and exposure\ndataset::Int: dataset identifier\ntrack_id::Int: unique molecule identifier \nstate::Symbol: molecular state (:monomer or :dimer)\npartner_id::Union{Int,Nothing}: ID of linked molecule (for dimers), or nothing for monomers\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.InteractionDiffusion.DiffusingEmitter3D","page":"API Reference","title":"SMLMSim.InteractionDiffusion.DiffusingEmitter3D","text":"DiffusingEmitter3D{T<:AbstractFloat} <: AbstractDiffusingEmitter\n\nA 3D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.\n\nFields\n\nx::T: x-coordinate in microns\ny::T: y-coordinate in microns\nz::T: z-coordinate in microns\nphotons::T: number of photons emitted\ntimestamp::T: actual simulation time in seconds\nframe::Int: camera frame number based on framerate and exposure\ndataset::Int: dataset identifier\ntrack_id::Int: unique molecule identifier\nstate::Symbol: molecular state (:monomer or :dimer)\npartner_id::Union{Int,Nothing}: ID of linked molecule (for dimers), or nothing for monomers\n\n\n\n\n\n","category":"type"},{"location":"api/#SMLMSim.InteractionDiffusion.DiffusionSMLMParams","page":"API Reference","title":"SMLMSim.InteractionDiffusion.DiffusionSMLMParams","text":"DiffusionSMLMParams <: SMLMSimParams\n\nParameters for diffusion-based SMLM simulation using Smoluchowski dynamics.\n\nFields\n\ndensity::Float64: number density (molecules/μm²)\nbox_size::Float64: simulation box size (μm)\ndiff_monomer::Float64: monomer diffusion coefficient (μm²/s)\ndiff_dimer::Float64: dimer diffusion coefficient (μm²/s)\ndiff_dimer_rot::Float64: dimer rotational diffusion coefficient (rad²/s)\nk_off::Float64: dimer dissociation rate (s⁻¹)\nr_react::Float64: reaction radius (μm)\nd_dimer::Float64: monomer separation in dimer (μm)\ndt::Float64: time step (s)\nt_max::Float64: total simulation time (s)\nndims::Int: number of dimensions (2 or 3)\nboundary::String: boundary condition type (\"periodic\" or \"reflecting\")\ncamera_framerate::Float64: camera frames per second (Hz)\ncamera_exposure::Float64: camera exposure time per frame (s)\n\nExamples\n\n# Default parameters\nparams = DiffusionSMLMParams()\n\n# Custom parameters\nparams = DiffusionSMLMParams(\n    density = 1.0,           # 1 molecule per μm²\n    box_size = 20.0,         # 20μm × 20μm box\n    diff_monomer = 0.2,      # 0.2 μm²/s\n    diff_dimer = 0.1,        # 0.1 μm²/s\n    diff_dimer_rot = 0.8,    # 0.8 rad²/s\n    k_off = 0.1,             # 0.1 s⁻¹\n    r_react = 0.02,          # 20nm reaction radius\n    d_dimer = 0.06,          # 60nm dimer separation\n    dt = 0.005,              # 5ms time step\n    t_max = 20.0,            # 20s simulation\n    ndims = 3,               # 3D simulation\n    boundary = \"reflecting\", # reflecting boundaries\n    camera_framerate = 20.0, # 20 frames per second\n    camera_exposure = 0.04   # 40ms exposure per frame\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.copy-Union{Tuple{DiffusingEmitter2D{T}}, Tuple{T}} where T<:AbstractFloat","page":"API Reference","title":"Base.copy","text":"Base.copy(e::DiffusingEmitter2D)\n\nCreate a copy of a 2D diffusing emitter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.copy-Union{Tuple{DiffusingEmitter3D{T}}, Tuple{T}} where T<:AbstractFloat","page":"API Reference","title":"Base.copy","text":"Base.copy(e::DiffusingEmitter3D)\n\nCreate a copy of a 3D diffusing emitter.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.add_camera_frame_emitters!-Tuple{Any, Any, Any, Any, DiffusionSMLMParams}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.add_camera_frame_emitters!","text":"add_camera_frame_emitters!(camera_emitters, emitters, time, frame_num, params)\n\nAdd emitters to camera frames when they fall within an exposure window.\n\nArguments\n\ncamera_emitters::Vector{<:AbstractDiffusingEmitter}: Collection of emitters for camera frames\nemitters::Vector{<:AbstractDiffusingEmitter}: Current emitters from simulation\ntime::Float64: Current simulation time\nframe_num::Int: Current frame number\nparams::DiffusionSMLMParams: Simulation parameters\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.analyze_dimer_fraction-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.analyze_dimer_fraction","text":"analyze_dimer_fraction(smld::BasicSMLD)\n\nCalculate the fraction of dimers per frame.\n\nArguments\n\nsmld::BasicSMLD: SMLD containing all emitters\n\nReturns\n\nTuple{Vector{Int}, Vector{Float64}}: Frame numbers and dimer fractions\n\nExample\n\n# Calculate dimer fraction over time\nframes, fractions = analyze_dimer_fraction(smld)\nplot(frames, fractions, xlabel=\"Frame\", ylabel=\"Dimer Fraction\")\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.analyze_dimer_lifetime-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.analyze_dimer_lifetime","text":"analyze_dimer_lifetime(smld::BasicSMLD)\n\nCalculate the average lifetime of dimers.\n\nArguments\n\nsmld::BasicSMLD: SMLD containing all emitters\n\nReturns\n\nFloat64: Average dimer lifetime in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.apply_boundary-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, String}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.apply_boundary","text":"apply_boundary(e::AbstractDiffusingEmitter, box_size::Float64, boundary::String)\n\nApply boundary conditions to an emitter (generic fallback).\n\nArguments\n\ne::AbstractDiffusingEmitter: Emitter to apply boundary to\nbox_size::Float64: Simulation box size in microns\nboundary::String: Boundary condition type (\"periodic\" or \"reflecting\")\n\nReturns\n\nAbstractDiffusingEmitter: Emitter with boundary conditions applied\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, String}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.apply_boundary","text":"apply_boundary(e::DiffusingEmitter2D, box_size::Float64, boundary::String)\n\nApply boundary conditions to a 2D emitter.\n\nArguments\n\ne::DiffusingEmitter2D: Emitter to apply boundary to\nbox_size::Float64: Simulation box size in microns\nboundary::String: Boundary condition type (\"periodic\" or \"reflecting\")\n\nReturns\n\nDiffusingEmitter2D: New emitter with position constrained to the box\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, String}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.apply_boundary","text":"apply_boundary(e::DiffusingEmitter3D, box_size::Float64, boundary::String)\n\nApply boundary conditions to a 3D emitter.\n\nArguments\n\ne::DiffusingEmitter3D: Emitter to apply boundary to\nbox_size::Float64: Simulation box size in microns\nboundary::String: Boundary condition type (\"periodic\" or \"reflecting\")\n\nReturns\n\nDiffusingEmitter3D: New emitter with position constrained to the box\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.can_dimerize-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.can_dimerize","text":"can_dimerize(e1::AbstractDiffusingEmitter, e2::AbstractDiffusingEmitter, r_react::Float64)\n\nCheck if two emitters can form a dimer.\n\nArguments\n\ne1::AbstractDiffusingEmitter: First emitter\ne2::AbstractDiffusingEmitter: Second emitter\nr_react::Float64: Reaction radius in microns\n\nReturns\n\nBool: True if emitters can form a dimer\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters","page":"API Reference","title":"SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters","text":"convert_to_diffusing_emitters(emitters::Vector{<:AbstractEmitter}, photons::Float64=1000.0, state::Symbol=:monomer)\n\nConvert regular emitters to diffusing emitters for use as starting conditions.\n\nArguments\n\nemitters::Vector{<:AbstractEmitter}: Vector of static emitters to convert\nphotons::Float64=1000.0: Number of photons to assign\nstate::Symbol=:monomer: Initial state (:monomer or :dimer)\n\nReturns\n\nVector{<:AbstractDiffusingEmitter}: Vector of diffusing emitters\n\nExample\n\n# Convert static emitters to diffusing emitters\nstatic_emitters = smld_static.emitters\ndiffusing_emitters = convert_to_diffusing_emitters(static_emitters)\n\n# Use as starting conditions for a diffusion simulation\nparams = DiffusionSMLMParams(t_max=10.0)\nsmld = simulate(params; starting_conditions=diffusing_emitters)\n\n\n\n\n\n","category":"function"},{"location":"api/#SMLMSim.InteractionDiffusion.create_smld-Tuple{Vector{<:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, SMLMData.AbstractCamera, DiffusionSMLMParams}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.create_smld","text":"create_smld(emitters::Vector{<:AbstractDiffusingEmitter}, camera::AbstractCamera, params::DiffusionSMLMParams)\n\nConvert a collection of diffusing emitters to a BasicSMLD object.\n\nArguments\n\nemitters::Vector{<:AbstractDiffusingEmitter}: Collection of emitters from simulation\ncamera::AbstractCamera: Camera model for imaging\nparams::DiffusionSMLMParams: Simulation parameters\n\nReturns\n\nBasicSMLD: SMLD containing all emitters for further analysis or visualization\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, Float64}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.diffuse","text":"diffuse(e::DiffusingEmitter2D, diff_coef::Float64, dt::Float64)\n\nCreate a new emitter with updated position based on Brownian motion.\n\nArguments\n\ne::DiffusingEmitter2D: Emitter to update\ndiff_coef::Float64: Diffusion coefficient (μm²/s)\ndt::Float64: Time step (s)\n\nReturns\n\nDiffusingEmitter2D: New emitter with updated position\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, Float64}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.diffuse","text":"diffuse(e::DiffusingEmitter3D, diff_coef::Float64, dt::Float64)\n\nCreate a new 3D emitter with updated position based on Brownian motion.\n\nArguments\n\ne::DiffusingEmitter3D: Emitter to update\ndiff_coef::Float64: Diffusion coefficient (μm²/s)\ndt::Float64: Time step (s)\n\nReturns\n\nDiffusingEmitter3D: New emitter with updated position\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Vararg{Float64, 4}}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.diffuse_dimer","text":"diffuse_dimer(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)\n\nDiffuse a dimer with both translational and rotational components.\n\nArguments\n\ne1::DiffusingEmitter2D: First emitter in dimer\ne2::DiffusingEmitter2D: Second emitter in dimer\ndiff_trans::Float64: Translational diffusion coefficient (μm²/s)\ndiff_rot::Float64: Rotational diffusion coefficient (rad²/s)\nd_dimer::Float64: Dimer separation distance (μm)\ndt::Float64: Time step (s)\n\nReturns\n\nTuple{DiffusingEmitter2D, DiffusingEmitter2D}: Two new emitters with updated positions\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Vararg{Float64, 4}}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.diffuse_dimer","text":"diffuse_dimer(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)\n\nDiffuse a 3D dimer with both translational and rotational components.\n\nArguments\n\ne1::DiffusingEmitter3D: First emitter in dimer\ne2::DiffusingEmitter3D: Second emitter in dimer\ndiff_trans::Float64: Translational diffusion coefficient (μm²/s)\ndiff_rot::Float64: Rotational diffusion coefficient (rad²/s)\nd_dimer::Float64: Dimer separation distance (μm)\ndt::Float64: Time step (s)\n\nReturns\n\nTuple{DiffusingEmitter3D, DiffusingEmitter3D}: Two new emitters with updated positions\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Float64}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.dimerize","text":"dimerize(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, d_dimer::Float64)\n\nCreate two new emitters in dimer state from two monomers.\n\nArguments\n\ne1::DiffusingEmitter2D: First emitter\ne2::DiffusingEmitter2D: Second emitter\nd_dimer::Float64: Dimer separation distance in microns\n\nReturns\n\nTuple{DiffusingEmitter2D, DiffusingEmitter2D}: Two new emitters in dimer state\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Float64}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.dimerize","text":"dimerize(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, d_dimer::Float64)\n\nCreate two new emitters in dimer state from two monomers in 3D.\n\nArguments\n\ne1::DiffusingEmitter3D: First emitter\ne2::DiffusingEmitter3D: Second emitter\nd_dimer::Float64: Dimer separation distance in microns\n\nReturns\n\nTuple{DiffusingEmitter3D, DiffusingEmitter3D}: Two new emitters in dimer state\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Vector{<:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.dissociate","text":"dissociate(e::DiffusingEmitter2D, emitters::Vector{<:AbstractDiffusingEmitter})\n\nCreate two new monomers from a dimer.\n\nArguments\n\ne::DiffusingEmitter2D: Emitter part of a dimer\nemitters::Vector{<:AbstractDiffusingEmitter}: All emitters in the system\n\nReturns\n\nTuple{DiffusingEmitter2D, DiffusingEmitter2D}: Two new emitters in monomer state\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Vector{<:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T<:AbstractFloat","page":"API Reference","title":"SMLMSim.InteractionDiffusion.dissociate","text":"dissociate(e::DiffusingEmitter3D, emitters::Vector{<:AbstractDiffusingEmitter})\n\nCreate two new monomers from a 3D dimer.\n\nArguments\n\ne::DiffusingEmitter3D: Emitter part of a dimer\nemitters::Vector{<:AbstractDiffusingEmitter}: All emitters in the system\n\nReturns\n\nTuple{DiffusingEmitter3D, DiffusingEmitter3D}: Two new emitters in monomer state\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.extract_final_state-Tuple{SMLMData.AbstractSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.extract_final_state","text":"extract_final_state(smld::SMLD)\n\nExtract the emitters from the final frame of a simulation to use as starting conditions.\n\nArguments\n\nsmld::SMLD: SMLD containing emitters from a simulation\n\nReturns\n\nVector{<:AbstractEmitter}: Emitters from the final frame\n\nExample\n\n# Run a simulation\nparams = DiffusionSMLMParams(t_max=5.0)\nsmld = simulate(params)\n\n# Extract final state\nfinal_state = extract_final_state(smld)\n\n# Continue simulation with new parameters\nparams_new = DiffusionSMLMParams(t_max=10.0, diff_monomer=0.2)\nsmld_continued = simulate(params_new; starting_conditions=final_state)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.filter_by_state-Tuple{BasicSMLD, Symbol}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.filter_by_state","text":"filter_by_state(smld::BasicSMLD, state::Symbol)\n\nFilter emitters by their state (monomer or dimer).\n\nArguments\n\nsmld::BasicSMLD: The original SMLD with diffusing emitters\nstate::Symbol: State to filter by (:monomer or :dimer)\n\nReturns\n\nBasicSMLD: New SMLD containing only emitters with the specified state\n\nExample\n\n# Get only monomers\nmonomer_smld = filter_by_state(smld, :monomer)\n\n# Get only dimers\ndimer_smld = filter_by_state(smld, :dimer)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.get_dimers-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.get_dimers","text":"get_dimers(smld::BasicSMLD)\n\nExtract a new BasicSMLD containing only emitters in dimer state.\n\nArguments\n\nsmld::BasicSMLD: Original SMLD with all emitters\n\nReturns\n\nBasicSMLD: New SMLD containing only dimers\n\nExample\n\n# Extract only dimers from simulation results\nsmld = simulate(params)\ndimer_smld = get_dimers(smld)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.get_frame-Tuple{BasicSMLD, Int64}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.get_frame","text":"get_frame(smld::BasicSMLD, frame_num::Int)\n\nExtract emitters from a specific frame.\n\nArguments\n\nsmld::BasicSMLD: SMLD containing all emitters\nframe_num::Int: Frame number to extract\n\nReturns\n\nBasicSMLD: New SMLD containing only emitters from the specified frame\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.get_monomers-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.get_monomers","text":"get_monomers(smld::BasicSMLD)\n\nExtract a new BasicSMLD containing only emitters in monomer state.\n\nArguments\n\nsmld::BasicSMLD: Original SMLD with all emitters\n\nReturns\n\nBasicSMLD: New SMLD containing only monomers\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.initialize_emitters","page":"API Reference","title":"SMLMSim.InteractionDiffusion.initialize_emitters","text":"initialize_emitters(params::DiffusionSMLMParams, photons::Float64=1000.0; override_count::Union{Nothing, Int}=nothing)\n\nCreate initial emitter positions for the simulation.\n\nArguments\n\nparams::DiffusionSMLMParams: Simulation parameters\nphotons::Float64=1000.0: Number of photons per emitter\noverride_count::Union{Nothing, Int}=nothing: Optional override for the number of molecules\n\nReturns\n\nVector{<:AbstractDiffusingEmitter}: Vector of initialized emitters\n\n\n\n\n\n","category":"function"},{"location":"api/#SMLMSim.InteractionDiffusion.should_dissociate-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, Float64}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.should_dissociate","text":"should_dissociate(e::AbstractDiffusingEmitter, k_off::Float64, dt::Float64)\n\nCheck if a dimer should dissociate based on stochastic rate.\n\nArguments\n\ne::AbstractDiffusingEmitter: Emitter to check\nk_off::Float64: Dissociation rate (s⁻¹)\ndt::Float64: Time step (s)\n\nReturns\n\nBool: True if dimer should dissociate\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.track_state_changes-Tuple{BasicSMLD}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.track_state_changes","text":"track_state_changes(smld::BasicSMLD)\n\nTrack state changes of molecules over time.\n\nArguments\n\nsmld::BasicSMLD: SMLD containing all emitters\n\nReturns\n\nDict{Int, Vector{Tuple{Int, Symbol}}}: Dictionary mapping molecule IDs to vectors of (frame, state) pairs\n\nExample\n\n# Track state changes of molecules\nstate_history = track_state_changes(smld)\n\n# Plot state history for molecule 1\nhistory = state_history[1]\nframes = [h[1] for h in history]\nstates = [h[2] for h in history]\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.InteractionDiffusion.update_system-Tuple{Vector{<:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, DiffusionSMLMParams, Float64}","page":"API Reference","title":"SMLMSim.InteractionDiffusion.update_system","text":"update_system(emitters::Vector{<:AbstractDiffusingEmitter}, params::DiffusionSMLMParams, dt::Float64)\n\nUpdate all emitters based on Smoluchowski diffusion dynamics.\n\nArguments\n\nemitters::Vector{<:AbstractDiffusingEmitter}: Current emitters state\nparams::DiffusionSMLMParams: Simulation parameters\ndt::Float64: Time step\n\nReturns\n\nVector{<:AbstractDiffusingEmitter}: Updated emitters\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.simulate-Tuple{DiffusionSMLMParams}","page":"API Reference","title":"SMLMSim.simulate","text":"simulate(params::DiffusionSMLMParams; \n         starting_conditions::Union{Nothing, SMLD, Vector{<:AbstractDiffusingEmitter}}=nothing,\n         photons::Float64=1000.0, \n         override_count::Union{Nothing, Int}=nothing,\n         kwargs...)\n\nRun a Smoluchowski diffusion simulation and return a BasicSMLD object with emitters that have both frame number and timestamp information.\n\nArguments\n\nparams::DiffusionSMLMParams: Simulation parameters\n\nKeyword Arguments\n\nstarting_conditions::Union{Nothing, SMLD, Vector{<:AbstractDiffusingEmitter}}=nothing: Optional starting emitters\nphotons::Float64=1000.0: Number of photons per emitter\noverride_count::Union{Nothing, Int}=nothing: Optional override for the number of molecules\ncamera::Union{Nothing, AbstractCamera}=nothing: Camera model (default: IdealCamera with 100nm pixels)\nIf nothing, creates IdealCamera with dimensions matching box_size\nCan specify SCMOSCamera for realistic noise modeling\nAny additional parameters are ignored (allows unified interface with other simulate methods)\n\nReturns\n\nBasicSMLD: Single SMLD object containing all emitters across all frames\n\nExample\n\n# Set up parameters with camera settings\nparams = DiffusionSMLMParams(\n    density = 0.5,           # molecules per μm²\n    box_size = 10.0,         # μm\n    camera_framerate = 20.0, # 20 fps\n    camera_exposure = 0.04   # 40ms exposure\n)\n\n# Run basic simulation\nsmld = simulate(params)\n\n# Run simulation with exactly 2 particles\nsmld = simulate(params; override_count=2)\n\n# Use previous simulation state as starting conditions for a new simulation\nfinal_frame = maximum([e.frame for e in smld.emitters])\nfinal_state_emitters = filter(e -> e.frame == final_frame, smld.emitters)\nsmld_continued = simulate(params; starting_conditions=final_state_emitters)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages","page":"API Reference","title":"SMLMSim.CameraImages","text":"CameraImages\n\nModule for generating simulated camera images from SMLM data.\n\nThis module provides functions to:\n\nGenerate ideal camera images by integrating emitter photons over a PSF.\nAdd realistic camera noise (e.g., Poisson noise).\n\nUsage\n\nusing SMLMSim.CameraImages\n\n\n\n\n\n","category":"module"},{"location":"api/#SMLMSim.CameraImages.gen_image-Tuple{SMLMData.AbstractSMLD, AbstractPSF, Int64}","page":"API Reference","title":"SMLMSim.CameraImages.gen_image","text":"gen_image(smld::SMLD, psf::AbstractPSF, frame::Int; kwargs...) -> Matrix{T} where T<:Real\n\nGenerate a single camera image for a specific frame from SMLD data. See gen_images for full documentation of parameters.\n\nReturns\n\nA 2D camera image as Matrix{T} where T matches the type of emitter.photons\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages.gen_images-Tuple{SMLMData.AbstractSMLD, AbstractPSF}","page":"API Reference","title":"SMLMSim.CameraImages.gen_images","text":"gen_images(smld::SMLD, psf::AbstractPSF; kwargs...) -> Array{T, 3} where T<:Real\n\nGenerate camera images from SMLD data using the specified PSF model.\n\nArguments\n\nsmld::SMLD: Single molecule localization data container\npsf::AbstractPSF: Point spread function model\n\nKeyword arguments\n\ndataset::Int=1: Dataset number to use from SMLD\nframes=nothing: Specific frames to generate (default: all frames in smld.n_frames)\nsupport::Union{Real,Tuple{<:Real,<:Real,<:Real,<:Real}}=Inf: PSF support region size:\nInf (default): Calculate PSF over the entire image (most accurate but slowest)\nReal: Circular region with specified radius (in microns) around each emitter\nTuple{<:Real,<:Real,<:Real,<:Real}: Explicit region as (xmin, xmax, ymin, ymax) in microns\nsampling::Int=2: Supersampling factor for PSF integration\nthreaded::Bool=true: Enable multithreading for faster computation\nbg::Float64=0.0: Background signal level (photons per pixel)\npoisson_noise::Bool=false: Apply Poisson noise only (for simple shot noise)\ncamera_noise::Bool=false: Apply full camera noise model (requires SCMOSCamera)\nFor SCMOSCamera: applies QE, Poisson, read noise, gain, and offset\nFor IdealCamera: ignored (use poisson_noise instead)\n\nReturns\n\n3D array of camera images with dimensions [height, width, num_frames]\nThe element type T matches the type of emitter.photons (typically Float64)\n\nPerformance Note\n\nFor the support parameter, using a finite radius (typically 3-5× the PSF width)  provides a good balance between accuracy and performance. For example, with a PSF width of 0.15μm, a support radius of 0.5-1.0μm is usually sufficient.\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages.poisson_noise!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Real","page":"API Reference","title":"SMLMSim.CameraImages.poisson_noise!","text":"poisson_noise!(image::AbstractArray{T}) where T<:Real -> nothing\n\nApply Poisson noise to an image or image stack in-place.\n\nArguments\n\nimage::AbstractArray{T}: Input image or image stack with values representing photon counts\n\nReturns\n\nnothing: The input array is modified in-place\n\nDetails\n\nSame as poisson_noise, but modifies the input array directly instead of creating a new one. This can be more memory-efficient for large images or when processing multiple frames.\n\nExample\n\n# Add Poisson noise to an image in-place\nimage = ones(100, 100) * 100.0  # 100 expected photons per pixel\npoisson_noise!(image)  # image is modified in-place\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages.poisson_noise-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Real","page":"API Reference","title":"SMLMSim.CameraImages.poisson_noise","text":"poisson_noise(image::AbstractArray{T}) where T<:Real -> Array{Float64}\n\nApply Poisson noise to an image or image stack.\n\nArguments\n\nimage::AbstractArray{T}: Input image or image stack with values representing photon counts\n\nReturns\n\nArray with same dimensions as input, with Poisson noise applied to each pixel\n\nDetails\n\nThis function creates a copy of the input array and applies Poisson noise  to each pixel using the in-place poisson_noise! function.\n\nNon-integer and negative values are handled specially:\n\nNon-integer values are accepted (treating them as expected photon counts)\nNegative values are clipped to zero before applying noise\nZero values remain zero (as Poisson(0) always returns 0)\n\nExample\n\n# Add Poisson noise to a clean image\nclean_image = ones(100, 100) * 100.0  # 100 expected photons per pixel\nnoisy_image = poisson_noise(clean_image)\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages.scmos_noise!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T<:Real","page":"API Reference","title":"SMLMSim.CameraImages.scmos_noise!","text":"scmos_noise!(image::AbstractMatrix{T}, camera::SCMOSCamera) where T<:Real -> nothing\n\nApply realistic sCMOS camera noise model to an image in-place.\n\nArguments\n\nimage::AbstractMatrix{T}: Input image with values representing photon counts (modified in-place)\ncamera::SCMOSCamera: sCMOS camera with calibration parameters\n\nReturns\n\nnothing: The input array is modified in-place\n\nDetails\n\nSame as scmos_noise, but modifies the input array directly instead of creating a new one.\n\nExample\n\ncamera = SCMOSCamera(128, 128, 0.1, 1.6)\nimage = ones(128, 128) * 100.0\nscmos_noise!(image, camera)  # image is modified in-place\n\n\n\n\n\n","category":"method"},{"location":"api/#SMLMSim.CameraImages.scmos_noise-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T<:Real","page":"API Reference","title":"SMLMSim.CameraImages.scmos_noise","text":"scmos_noise(image::AbstractMatrix{T}, camera::SCMOSCamera) where T<:Real -> Matrix{Float64}\n\nApply realistic sCMOS camera noise model to an image.\n\nArguments\n\nimage::AbstractMatrix{T}: Input image with values representing photon counts\ncamera::SCMOSCamera: sCMOS camera with calibration parameters (offset, gain, readnoise, qe)\n\nReturns\n\nMatrix with same dimensions as input, with full sCMOS noise model applied\n\nDetails\n\nThe sCMOS noise model applies the following transformations in order:\n\nQuantum efficiency: Convert photons to photoelectrons\nPoisson noise: Shot noise on photoelectrons\nRead noise: Gaussian noise per pixel\nGain: Convert electrons to ADU (analog-to-digital units)\nOffset: Add dark level\n\nThe process simulates the physical detection chain:\n\nQE: Not all photons generate photoelectrons\nPoisson: Fundamental shot noise\nRead noise: Electronic noise from amplifier/ADC\nGain & Offset: Conversion to digital units\n\nExample\n\n# Create an sCMOS camera with 1.6 e⁻ read noise\ncamera = SCMOSCamera(128, 128, 0.1, 1.6)\n\n# Apply realistic noise to a clean image\nclean_image = ones(128, 128) * 100.0  # 100 photons per pixel\nnoisy_image = scmos_noise(clean_image, camera)\n\n\n\n\n\n","category":"method"},{"location":"core/photophysics/#Fluorophore-Photophysics","page":"Photophysics","title":"Fluorophore Photophysics","text":"This page covers the photophysical models in SMLMSim and how they're used to generate realistic blinking behavior for SMLM simulations.","category":"section"},{"location":"core/photophysics/#Overview","page":"Photophysics","title":"Overview","text":"Fluorophores in single-molecule microscopy exhibit complex photophysical behavior, including:\n\nStochastic switching between fluorescent (ON) and non-fluorescent (OFF) states\nVarying photon emission rates\nPhotobleaching (permanent transition to a dark state)\n\nSMLMSim models these behaviors using kinetic state models and stochastic simulation of state transitions.","category":"section"},{"location":"core/photophysics/#Fluorophore-Models","page":"Photophysics","title":"Fluorophore Models","text":"","category":"section"},{"location":"core/photophysics/#GenericFluor","page":"Photophysics","title":"GenericFluor","text":"The main fluorophore model in SMLMSim is the GenericFluor type:\n\nusing SMLMSim\n\n# Define a two-state fluorophore using the positional constructor\n# Note: q matrix already had correct diagonal elements, just removed γ=\nfluor = GenericFluor(10000.0, [-5.0 5.0; 10.0 -10.0])\n\n# ... rest of the example ...\n\nParameters:\n\nγ: Photon emission rate in Hz (photons per second)\nq: State transition rate matrix where q[i,j] is the transition rate from state i to j (in s⁻¹)\n\nBy convention, state 1 is the fluorescent (ON) state, and other states are non-fluorescent (OFF).","category":"section"},{"location":"core/photophysics/#Kinetic-Models","page":"Photophysics","title":"Kinetic Models","text":"","category":"section"},{"location":"core/photophysics/#Continuous-Time-Markov-Chain","page":"Photophysics","title":"Continuous Time Markov Chain","text":"Fluorophore state transitions are modeled using a Continuous Time Markov Chain (CTMC):\n\n# Create a CTMC for a two-state system\n# State 1: ON (fluorescent), State 2: OFF (dark)\nq = [-5 5; 10 -10]  # Units: s⁻¹\nsimulation_time = 10.0  # seconds\ninitial_state = 2  # Start in dark state\n\nctmc = CTMC(q, simulation_time, initial_state)","category":"section"},{"location":"core/photophysics/#Understanding-the-Rate-Matrix","page":"Photophysics","title":"Understanding the Rate Matrix","text":"The transition rate matrix q represents the rates at which the system transitions between states:\n\nq[i,j] (i≠j): Rate of transition from state i to state j\nq[i,i]: Negative sum of all outgoing rates from state i\n\nFor example, in a two-state system:\n\nq = [-k_off  k_off;\n      k_on   -k_on]\n\nWhere:\n\nk_off: Rate of transitioning from ON (state 1) to OFF (state 2)\nk_on: Rate of transitioning from OFF (state 2) to ON (state 1)\nDiagonal elements are negative sums of their respective rows\n\nThe CTMC simulates transitions between states by:\n\nSampling the time until the next transition (exponentially distributed with rate -q[current,current])\nSampling the next state with probabilities proportional to the transition rates\n\nThe CTMC provides a complete trajectory of state transitions:\n\n# Get state at a specific time\nstate_at_1s = get_state(ctmc, 1.0)\n\n# Get next state transition after a specific time\nnext_state, transition_time = get_next(ctmc, 0.5)","category":"section"},{"location":"core/photophysics/#Intensity-Traces","page":"Photophysics","title":"Intensity Traces","text":"To simulate the fluorescence signal over time, SMLMSim integrates photon emission during ON states:\n\n# Generate intensity trace for 1000 frames at 50 fps\nfluor = GenericFluor(γ=10000.0, q=[-5 5; 10 -10])\nphotons = intensity_trace(fluor, 1000, 50.0)\n\nThe intensity_trace function:\n\nSimulates the CTMC state trajectory\nIntegrates photon emission (rate γ) during ON states\nAccumulates photons within each frame's exposure time","category":"section"},{"location":"core/photophysics/#Common-Photophysical-Models","page":"Photophysics","title":"Common Photophysical Models","text":"","category":"section"},{"location":"core/photophysics/#Two-State-Model","page":"Photophysics","title":"Two-State Model","text":"The simplest model contains just ON and OFF states:\n\n# Two-state model (ON ⟷ OFF)\n# kon = 5 s⁻¹, koff = 10 s⁻¹\nfluor = GenericFluor(\n    γ=1e4,                # 10,000 photons/s\n    q=[-10 10; 5 -5]      # [ON→OFF; OFF→ON] rates in s⁻¹\n)\n\nThis produces exponentially distributed ON and OFF times.","category":"section"},{"location":"core/photophysics/#Three-State-Model-with-Bleaching","page":"Photophysics","title":"Three-State Model with Bleaching","text":"For more realistic behavior including photobleaching:\n\n# Three-state model (ON ⟷ OFF → BLEACHED)\n# State 1: ON, State 2: OFF, State 3: BLEACHED\nfluor = GenericFluor(\n    γ=1e4,\n    q=[-10.1 10 0.1; 5 -5 0; 0 0 0]  # Note: state 3 is absorbing (no outgoing transitions)\n)\n\nThe third state is irreversible (absorbing state), representing photobleaching.","category":"section"},{"location":"core/photophysics/#Using-Photophysics-in-Simulations","page":"Photophysics","title":"Using Photophysics in Simulations","text":"The simulate() function integrates these photophysical models automatically:\n\n# Simulation with custom fluorophore\ncamera = IdealCamera(128, 128, 0.1)\nfluor = GenericFluor(γ=2e4, q=[-20 20; 5 -5])\n\nsmld_true, smld_model, smld_noisy = simulate(\n    molecule=fluor,\n    framerate=50.0,     # frames per second\n    nframes=2000,       # total frames\n    minphotons=100,     # detection threshold\n    camera=camera\n)\n\nBehind the scenes, this uses the kinetic_model() function to apply the photophysical model to each emitter position.","category":"section"},{"location":"core/photophysics/#Photophysical-Parameters-and-Duty-Cycle","page":"Photophysics","title":"Photophysical Parameters and Duty Cycle","text":"The photophysical properties determine the \"duty cycle\" - the fraction of time a fluorophore is in the ON state:\n\nFor a two-state model, the duty cycle is:\n\nduty_cycle = kon / (kon + koff)\n\nWhere:\n\nkon is the OFF→ON rate (q[2,1] in the rate matrix)\nkoff is the ON→OFF rate (q[1,2] in the rate matrix)\n\nTypical duty cycles for SMLM fluorophores range from 0.0001 to 0.01.","category":"section"},{"location":"diffusion/examples/#Diffusion-Interaction-Examples","page":"Examples","title":"Diffusion-Interaction Examples","text":"This page provides complete examples for using the diffusion-interaction simulation capabilities of SMLMSim.","category":"section"},{"location":"diffusion/examples/#Working-with-Trajectories","page":"Examples","title":"Working with Trajectories","text":"SMLMSim provides several utility functions for working with trajectories:\n\nget_track(smld, id): Returns a new SMLD containing only emitters with the specified track_id\nget_num_tracks(smld): Returns the number of unique tracks in an SMLD\nget_tracks(smld): Returns a vector of SMDLs, one for each unique track\n\nThese functions are useful for analyzing and visualizing trajectory data, as demonstrated in the examples below.","category":"section"},{"location":"diffusion/examples/#Basic-Diffusion-Simulation","page":"Examples","title":"Basic Diffusion Simulation","text":"This example demonstrates how to run a basic diffusion simulation and visualize the results:\n\nusing SMLMSim\nusing CairoMakie\nusing MicroscopePSFs\n\n# Set up simulation parameters\nparams = DiffusionSMLMParams(\n    density = 2.0,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    r_react = 0.01,       # μm\n    d_dimer = 0.05,       # μm\n    dt = 0.01,            # s\n    t_max = 10.0,         # s\n    camera_framerate = 10.0  # fps\n)\n\n# Run simulation\nsmld = simulate(params; photons=1000.0)\n\n# Extract coordinates based on monomer/dimer state for a specific frame\nfunction extract_frame_by_state(smld, frame_num)\n    # This approach doesn't use our new utility functions directly yet,\n    # but demonstrates what would be useful additions in the future\n    # (e.g., get_frame and filter_by_state functions)\n    \n    # Filter emitters for this frame the traditional way\n    frame_emitters = filter(e -> e.frame == frame_num, smld.emitters)\n    \n    # Extract coordinates and states\n    x = [e.x for e in frame_emitters]\n    y = [e.y for e in frame_emitters]\n    states = [e.state for e in frame_emitters]\n    \n    # Create state-based colors\n    colors = map(states) do state\n        state == :monomer ? :blue : :red\n    end\n    \n    return x, y, colors\nend\n\n# Create visualization for multiple frames\nframes_to_show = [1, 20, 40, 60, 80, 100]\nfig = Figure(size=(1000, 600))\n\nfor (i, frame) in enumerate(frames_to_show)\n    # Calculate subplot position (2x3 grid)\n    row = div(i-1, 3) + 1\n    col = rem(i-1, 3) + 1\n    \n    # Create axis\n    ax = Axis(fig[row, col], \n        title=\"Frame $frame\",\n        xlabel=\"x (μm)\",\n        ylabel=\"y (μm)\",\n        aspect=DataAspect()\n    )\n    \n    # Extract and plot data\n    x, y, colors = extract_frame_by_state(smld, frame)\n    scatter!(ax, x, y, color=colors, markersize=6)\n    \n    # Set consistent axis limits\n    limits!(ax, 0, params.box_size, 0, params.box_size)\nend\n\n# Add legend\nfig[1:2, 4] = Legend(fig, \n    [MarkerElement(color=:blue, marker=:circle), \n     MarkerElement(color=:red, marker=:circle)],\n    [\"Monomer\", \"Dimer\"],\n    \"Molecular States\"\n)\n\nfig\n","category":"section"},{"location":"diffusion/examples/#Frame-Integration-for-Time-Lapse-Imaging","page":"Examples","title":"Frame Integration for Time-Lapse Imaging","text":"This example demonstrates how to use frame integration to create realistic time-lapse microscopy data from diffusion simulations:\n\nusing SMLMSim\nusing MicroscopePSFs\nusing CairoMakie\n\n# Set up diffusion parameters with high temporal resolution\nparams = DiffusionSMLMParams(\n    density = 1.0,          # molecules per μm²\n    box_size = 10.0,        # μm\n    diff_monomer = 0.2,     # μm²/s (moderate diffusion)\n    diff_dimer = 0.1,       # μm²/s\n    k_off = 0.1,            # s⁻¹\n    r_react = 0.01,         # μm\n    d_dimer = 0.05,         # μm\n    dt = 0.001,             # s (1ms time steps for accurate diffusion)\n    t_max = 5.0,            # s (5 seconds total)\n    camera_framerate = 10.0, # fps (10 frames per second)\n    camera_exposure = 0.1    # s (100ms exposure time)\n)\n\n# Run simulation\nsmld = simulate(params)\n\n# Setup camera and PSF\npixelsize = 0.1  # 100nm pixels\npixels = Int64(round(params.box_size/pixelsize))\ncamera = IdealCamera(1:pixels, 1:pixels, pixelsize)\n\n# Create PSF model\npsf = MicroscopePSFs.GaussianPSF(0.15)  # 150nm PSF width\n\n# Generate microscope images from simulation\n# For diffusion simulations, the camera integration time (exposure) has already been\n# modeled in the simulation process, so each frame already includes the positions\n# from all emitters that appeared during the exposure window\nimages = gen_images(smld, psf;\n    bg=5.0,               # background photons per pixel\n    poisson_noise=true     # add photon counting noise\n)\n\n# Display a single frame\nfig = Figure(size=(600, 600))\nax = Axis(fig[1, 1],\n    title=\"Diffusion with Frame Integration\",\n    aspect=DataAspect(),\n    yreversed=true\n)\n\n# Select a frame to display\nframe_to_show = 3  # Changed from 15 to a valid frame index (between 1 and 6)\nheatmap!(ax, transpose(images[:, :, frame_to_show]), colormap=:inferno)\n\nfig\n\nThe simulation already handles motion blur effects in a realistic way:\n\nThe camera_exposure parameter in the simulation determines how long each camera frame integrates photons\nDuring the exposure window, multiple emitter positions from the same track_id are captured\nThis naturally creates motion blur effects where fast-moving particles appear more blurred\nThe resulting images accurately represent what would be seen in real microscopy experiments","category":"section"},{"location":"diffusion/examples/#Analyzing-Dimer-Formation","page":"Examples","title":"Analyzing Dimer Formation","text":"This example demonstrates how to analyze dimer formation dynamics:\n\nusing SMLMSim\nusing CairoMakie\n\n# Set up simulations with different dissociation rates\nparams_stable = DiffusionSMLMParams(\n    density = 1.0,        # molecules per μm²\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.05,         # s⁻¹ (stable dimers)\n    t_max = 20.0          # s\n)\n\nparams_unstable = DiffusionSMLMParams(\n    density = 1.0,        # molecules per μm²\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.5,          # s⁻¹ (unstable dimers)\n    t_max = 20.0          # s\n)\n\n# Run simulations\nsmld_stable = simulate(params_stable)\nsmld_unstable = simulate(params_unstable)\n\n# Analyze dimer formation\nframes_stable, frac_stable = analyze_dimer_fraction(smld_stable)\nframes_unstable, frac_unstable = analyze_dimer_fraction(smld_unstable)\n\n# Calculate time in seconds\ntime_stable = (frames_stable .- 1) ./ params_stable.camera_framerate\ntime_unstable = (frames_unstable .- 1) ./ params_unstable.camera_framerate\n\n# Visualize dimer formation dynamics\nfig = Figure(size=(800, 500))\n\nax = Axis(fig[1, 1],\n    title=\"Dimer Formation Dynamics\",\n    xlabel=\"Time (s)\",\n    ylabel=\"Fraction of molecules in dimers\"\n)\n\nlines!(ax, time_stable, frac_stable, linewidth=3, color=:blue, \n       label=\"Stable (k_off=0.05 s⁻¹)\")\nlines!(ax, time_unstable, frac_unstable, linewidth=3, color=:red, \n       label=\"Unstable (k_off=0.5 s⁻¹)\")\n\naxislegend(ax)\n\nfig\n","category":"section"},{"location":"diffusion/examples/#Generating-Microscope-Images","page":"Examples","title":"Generating Microscope Images","text":"This example shows how to generate microscope images from diffusion simulations:\n\nusing SMLMSim\nusing CairoMakie\nusing MicroscopePSFs\n\n# Set simulation parameters\nparams = DiffusionSMLMParams(\n    density = 0.3,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    r_react = 0.01,       # μm\n    d_dimer = 0.05,       # μm\n    dt = 0.01,            # s\n    t_max = 5.0,          # s\n    camera_framerate = 10.0,  # fps\n    camera_exposure = 0.1     # s\n)\n\n# Run simulation\nsmld = simulate(params)\n\n# Set up camera and PSF\npixelsize = 0.1  # 100nm pixels\npixels = Int64(round(params.box_size/pixelsize))\ncamera = IdealCamera(1:pixels, 1:pixels, pixelsize)\n\n# Set up PSF (Gaussian with 150nm width)\npsf = MicroscopePSFs.GaussianPSF(0.15)  # 150nm PSF width\n\n# Generate images for all molecules\nimages_all = gen_images(smld, psf;\n    bg=5.0,\n    poisson_noise=true\n)\n\n# Extract only dimers\ndimer_smld = get_dimers(smld)\n\n# Generate images showing only dimers\nimages_dimers = gen_images(dimer_smld, psf;\n    bg=5.0,\n    poisson_noise=true\n)\n\n# Visualize images\nfunction display_frames(images_all, images_dimers, frame_indices)\n    fig = Figure(size=(1200, 800))\n    \n    for (i, frame) in enumerate(frame_indices)\n        # Row 1: All molecules\n        ax1 = Axis(fig[1, i], \n            title=\"All Molecules - Frame $frame\",\n            aspect=DataAspect(),\n            yreversed=true\n        )\n        hidedecorations!(ax1)\n        \n        # Row 2: Dimers only\n        ax2 = Axis(fig[2, i], \n            title=\"Dimers Only - Frame $frame\",\n            aspect=DataAspect(),\n            yreversed=true\n        )\n        hidedecorations!(ax2)\n        \n        # Display images\n        heatmap!(ax1, transpose(images_all[:, :, frame]), colormap=:inferno)\n        heatmap!(ax2, transpose(images_dimers[:, :, frame]), colormap=:inferno)\n    end\n    \n    return fig\nend\n\n# Show frames 10, 20, 30\nframe_indices = [10, 20, 30]\nfig = display_frames(images_all, images_dimers, frame_indices)","category":"section"},{"location":"diffusion/examples/#Two-Interacting-Particles","page":"Examples","title":"Two Interacting Particles","text":"This example shows two particles interacting in a small box with reflecting boundary conditions, using the new starting conditions feature to place them at specific initial positions:\n\nusing SMLMSim\nusing CairoMakie\n\n# Set up a minimal simulation with just two particles\nparams = DiffusionSMLMParams(\n    box_size = 1.0,       # 1 μm box for close interactions\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.5,          # s⁻¹ (moderate dimer stability)\n    r_react = 0.05,       # μm (large reaction radius for demonstration)\n    d_dimer = 0.07,       # μm (dimer separation)\n    dt = 0.01,            # s\n    t_max = 5.0,          # s\n    boundary = \"reflecting\",  # Reflecting boundaries\n    camera_framerate = 10.0   # fps\n)\n\n# Create two particles with specific initial positions\nparticle1 = DiffusingEmitter2D{Float64}(\n    0.2, 0.2,       # Position in lower-left quadrant\n    1000.0,         # Photons\n    0.0,            # Initial timestamp\n    1,              # Initial frame\n    1,              # Dataset\n    1,              # track_id\n    :monomer,       # Initial state\n    nothing         # No partner initially\n)\n\nparticle2 = DiffusingEmitter2D{Float64}(\n    0.8, 0.8,       # Position in upper-right quadrant\n    1000.0,         # Photons\n    0.0,            # Initial timestamp\n    1,              # Initial frame\n    1,              # Dataset\n    2,              # track_id\n    :monomer,       # Initial state\n    nothing         # No partner initially\n)\n\n# Run simulation with custom starting positions\nsmld = simulate(params; starting_conditions=[particle1, particle2])\n\ntrack_smlds = get_tracks(smld)\n\n# Convert to the format needed for plotting\ntrajectories = []\nfor track_smld in track_smlds\n    # Get ID from first emitter\n    id = track_smld.emitters[1].track_id\n    \n    # Sort by timestamp\n    sort!(track_smld.emitters, by = e -> e.timestamp)\n    \n    # Extract coordinates and state\n    times = [e.timestamp for e in track_smld.emitters]\n    x = [e.x for e in track_smld.emitters]\n    y = [e.y for e in track_smld.emitters]\n    states = [e.state for e in track_smld.emitters]\n    \n    push!(trajectories, (id=id, times=times, x=x, y=y, states=states))\nend\n\n# Visualize interaction dynamics\nfig = Figure(size=(700, 600))\n\nax = Axis(fig[1, 1], \n    title=\"Two Particles in 1μm Box (Reflecting Boundaries)\",\n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    aspect=DataAspect()\n)\n\n# Plot trajectories with state-dependent coloring\nfor (i, traj) in enumerate(trajectories)\n    # Create segments with colors based on state\n    segments_x = []\n    segments_y = []\n    colors = []\n    \n    for j in 1:(length(traj.times)-1)\n        push!(segments_x, [traj.x[j], traj.x[j+1]])\n        push!(segments_y, [traj.y[j], traj.y[j+1]])\n        push!(colors, traj.states[j] == :monomer ? :blue : :red)\n    end\n    \n    # Plot each segment with appropriate color\n    for j in 1:length(segments_x)\n        lines!(ax, segments_x[j], segments_y[j], \n               color=colors[j], linewidth=2, \n               label=j==1 ? \"Particle $(traj.id)\" : nothing)\n    end\n    \n    # Mark starting position\n    scatter!(ax, [traj.x[1]], [traj.y[1]], \n            color=:black, marker=:circle, markersize=10)\n    \n    # Mark ending position\n    scatter!(ax, [traj.x[end]], [traj.y[end]], \n            color=:black, marker=:star, markersize=12)\nend\n\n# Show box boundaries\nbox = [0 0; 1 0; 1 1; 0 1; 0 0]\nlines!(ax, box[:, 1], box[:, 2], color=:black, linewidth=2)\n\n# Add legend for state colors\nlegend_elements = [\n    LineElement(color=:blue, linewidth=3),\n    LineElement(color=:red, linewidth=3),\n    MarkerElement(color=:black, marker=:circle, markersize=8),\n    MarkerElement(color=:black, marker=:star, markersize=10)\n]\nlegend_labels = [\"Monomer\", \"Dimer\", \"Start\", \"End\"]\n\nLegend(fig[1, 2], legend_elements, legend_labels, \"States\")\n\n# Set axis limits with some padding\nlimits!(ax, -0.05, 1.05, -0.05, 1.05)\n\nfig\n","category":"section"},{"location":"diffusion/overview/#Diffusion-Interaction-Simulation","page":"Overview","title":"Diffusion-Interaction Simulation","text":"","category":"section"},{"location":"diffusion/overview/#Overview","page":"Overview","title":"Overview","text":"The Diffusion-Interaction module simulates dynamic molecular processes including diffusion and interactions between particles in a controlled environment. This allows you to model realistic molecular behaviors such as:\n\nFree diffusion of monomers\nFormation of molecular complexes (dimers)\nDissociation of complexes\nCombined translational and rotational diffusion\n\nThe simulation operates within a defined box with customizable physical parameters, making it suitable for studying a wide range of biological phenomena at the single-molecule level.","category":"section"},{"location":"diffusion/overview/#Simulation-Model","page":"Overview","title":"Simulation Model","text":"The diffusion simulation is based on the Smoluchowski dynamics model with the following components:\n\nParticles: Represented as point particles (monomers) or rigid structures (dimers)\nDiffusion: Isotropic Brownian motion with specified diffusion coefficients\nReactions: \nAssociation: Two monomers within reaction radius form a dimer\nDissociation: Dimers break with rate k_off\nBoundaries: Periodic or reflecting boundary conditions\n\nAt each time step, the simulation:\n\nUpdates molecular states (dimerization/dissociation)\nUpdates positions with appropriate diffusion models\nHandles boundary conditions","category":"section"},{"location":"diffusion/overview/#Physical-Units","page":"Overview","title":"Physical Units","text":"All simulation parameters use consistent physical units:\n\nSpatial dimensions: microns (μm)\nTime: seconds (s)\nDiffusion coefficients: μm²/s\nRate constants: s⁻¹","category":"section"},{"location":"diffusion/overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"","category":"section"},{"location":"diffusion/overview/#Running-a-Basic-Simulation","page":"Overview","title":"Running a Basic Simulation","text":"The main interface for running diffusion simulations is the simulate function with DiffusionSMLMParams:\n\nusing SMLMSim\n\n# Set simulation parameters\nparams = DiffusionSMLMParams(\n    density = 0.5,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    r_react = 0.01,       # μm\n    d_dimer = 0.05,       # μm\n    dt = 0.01,            # s\n    t_max = 10.0          # s\n)\n\n# Run the simulation\nsmld = simulate(params)\n\nThe smld output is a BasicSMLD structure containing all emitters across all time points, with each emitter having frame information corresponding to the camera settings.","category":"section"},{"location":"diffusion/overview/#Simulation-Parameters","page":"Overview","title":"Simulation Parameters","text":"The DiffusionSMLMParams structure allows you to customize various aspects of the simulation:\n\n# More complex simulation\nparams = DiffusionSMLMParams(\n    density = 2.0,           # Higher density\n    box_size = 20.0,         # Larger area\n    diff_monomer = 0.2,      # Faster monomer diffusion\n    diff_dimer = 0.08,       # Faster dimer diffusion\n    diff_dimer_rot = 1.0,    # Faster rotational diffusion\n    k_off = 0.05,            # Slower dissociation (more stable dimers)\n    r_react = 0.015,         # Larger reaction radius\n    d_dimer = 0.08,          # Larger dimer separation\n    dt = 0.005,              # Smaller time step (higher precision)\n    t_max = 30.0,            # Longer simulation\n    ndims = 2,               # 2D simulation (default)\n    boundary = \"periodic\",   # Periodic boundaries (default)\n    camera_framerate = 20.0, # Camera frames per second\n    camera_exposure = 0.04   # Camera exposure time\n)","category":"section"},{"location":"diffusion/overview/#Microscope-Image-Generation","page":"Overview","title":"Microscope Image Generation","text":"The diffusion simulation can be converted into realistic microscope images using point spread function models.","category":"section"},{"location":"diffusion/overview/#Creating-Images-from-Simulation-Data","page":"Overview","title":"Creating Images from Simulation Data","text":"# Set up camera and PSF\npixelsize = 0.1  # 100nm pixels\npixels = Int64(round(params.box_size/pixelsize))\ncamera = IdealCamera(1:pixels, 1:pixels, pixelsize)\n\n# Set up PSF (Gaussian with 150nm width)\nusing MicroscopePSFs\npsf = MicroscopePSFs.GaussianPSF(0.15)  # 150nm PSF width\n\n# Generate images\nimage_stack = gen_images(smld, psf;\n    photons=1000.0,\n    bg=5.0,\n    poisson_noise=true\n)","category":"section"},{"location":"diffusion/overview/#Analyzing-Results","page":"Overview","title":"Analyzing Results","text":"","category":"section"},{"location":"diffusion/overview/#Extracting-Dimers","page":"Overview","title":"Extracting Dimers","text":"To focus on the behavior of dimers, you can extract only the molecules in dimer state:\n\n# Extract dimers from the full simulation\ndimer_smld = get_dimers(smld)","category":"section"},{"location":"diffusion/overview/#Analyzing-Dimer-Formation","page":"Overview","title":"Analyzing Dimer Formation","text":"To quantify the formation of dimers over time:\n\n# Calculate fraction of molecules in dimer state\nframes, dimer_fractions = analyze_dimer_fraction(smld)\n\n# Plot dimer formation over time\nusing CairoMakie\nfig = Figure()\nax = Axis(fig[1, 1],\n    xlabel=\"Frame\",\n    ylabel=\"Fraction of molecules in dimers\",\n    title=\"Dimer formation dynamics\"\n)\nlines!(ax, frames, dimer_fractions)\nfig","category":"section"},{"location":"diffusion/overview/#Emitter-Types","page":"Overview","title":"Emitter Types","text":"The diffusion module introduces specialized emitter types:\n\nDiffusingEmitter2D: 2D emitter with state information (monomer/dimer)\nDiffusingEmitter3D: 3D emitter with state information (monomer/dimer)\n\nThese types include additional properties:\n\ntimestamp: Actual simulation time\nstate: Molecular state (:monomer or :dimer)\npartner_id: ID of linked molecule (for dimers)","category":"section"},{"location":"images/#Microscope-Image-Generation","page":"Microscope Images","title":"Microscope Image Generation","text":"This page explains how to generate realistic microscope images from simulated SMLM data and the available noise options.","category":"section"},{"location":"images/#Overview","page":"Microscope Images","title":"Overview","text":"SMLMSim can convert SMLD objects containing emitter coordinates into realistic microscope image stacks using point spread function (PSF) models. This functionality enables:\n\nCreating synthetic microscope data for algorithm testing\nVisualizing simulated molecules\nGenerating training data for deep learning models\nTesting localization algorithms with realistic inputs","category":"section"},{"location":"images/#Basic-Image-Generation","page":"Microscope Images","title":"Basic Image Generation","text":"The primary functions for creating images are:\n\ngen_images: Generate multiple frames (3D stack)\ngen_image: Generate a single frame (2D image)","category":"section"},{"location":"images/#Creating-a-Full-Image-Stack","page":"Microscope Images","title":"Creating a Full Image Stack","text":"To generate a complete image stack from an SMLD object:\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Create or load an SMLD object\n# (This could be from either static or diffusion simulation)\nparams = StaticSMLMParams(density=1.0, σ_psf=0.13, nframes=1000)\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\npattern = Nmer2D(n=6, d=0.2)  # Hexamer with 200nm diameter\nmolecule = GenericFluor(1e4, [-50.0 50.0; 1e-2 -1e-2])  # Blinking model\n\n# Run simulation\nsmld_true, smld_model, smld_noisy = simulate(params, pattern=pattern, molecule=molecule, camera=camera)\n\n# Create a PSF model (Gaussian with 150nm width)\npsf = GaussianPSF(0.15)  # 150nm PSF width\n\n# Generate image stack from emitter data\nimages = gen_images(smld_model, psf; \n    bg=5.0,             # background photons per pixel\n    poisson_noise=true  # add realistic photon counting noise\n)\n\nThe resulting images is a 3D array with dimensions [height, width, frames] that can be used for visualization or algorithm development.","category":"section"},{"location":"images/#Creating-a-Single-Frame","page":"Microscope Images","title":"Creating a Single Frame","text":"To generate an image for a specific frame:\n\n# Generate image for frame 10\nframe_image = gen_image(smld_model, psf, 10;\n    bg=5.0,\n    poisson_noise=true\n)","category":"section"},{"location":"images/#Function-Parameters","page":"Microscope Images","title":"Function Parameters","text":"The gen_images function has the following signature:\n\ngen_images(smld::SMLD, psf::AbstractPSF; kwargs...) -> Array{T, 3} where T<:Real","category":"section"},{"location":"images/#Required-Parameters","page":"Microscope Images","title":"Required Parameters","text":"smld::SMLD: Single molecule localization data container\npsf::AbstractPSF: Point spread function model from MicroscopePSFs.jl","category":"section"},{"location":"images/#Optional-Keyword-Arguments","page":"Microscope Images","title":"Optional Keyword Arguments","text":"# Complete example with all available options\nimages = gen_images(smld_model, psf;\n    dataset::Int=1,                # Dataset number to use from SMLD\n    frames=nothing,                # Specific frames to generate (default: all frames)\n    support=Inf,                   # PSF support region size in μm (Inf, scalar, or tuple)\n    sampling=2,                    # Supersampling factor for PSF integration\n    threaded=true,                 # Enable multithreading for faster computation\n    bg=0.0,                        # Background signal level (photons per pixel)\n    poisson_noise=false,           # Apply Poisson noise only (simple shot noise)\n    camera_noise=false             # Apply full camera noise model (requires SCMOSCamera)\n)","category":"section"},{"location":"images/#Noise-Options","page":"Microscope Images","title":"Noise Options","text":"Realistic microscope images include various noise sources. SMLMSim supports the following options:","category":"section"},{"location":"images/#Photon-Shot-Noise","page":"Microscope Images","title":"Photon Shot Noise","text":"Photon shot noise follows a Poisson distribution and is the most fundamental noise source in fluorescence microscopy:\n\n# Enable Poisson noise (default: false)\nimages = gen_images(smld_model, psf, poisson_noise=true)\n\nWhen enabled, each pixel's intensity is drawn from a Poisson distribution with λ equal to the expected photon count.","category":"section"},{"location":"images/#Background-Signal","page":"Microscope Images","title":"Background Signal","text":"Background noise can be added as a constant offset to all pixels:\n\n# Add background signal (photons per pixel)\nimages = gen_images(smld_model, psf, bg=10.0)\n\nWhen combined with Poisson noise, the background is included in the Poisson sampling process for a realistic noise model.","category":"section"},{"location":"images/#sCMOS-Camera-Noise","page":"Microscope Images","title":"sCMOS Camera Noise","text":"For realistic camera noise modeling, SMLMSim supports sCMOS cameras with per-pixel calibration parameters. This applies the full detection chain from photons to ADU (analog-to-digital units):\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Create an sCMOS camera with realistic parameters\n# Parameters: width, height, pixel_size (μm), readnoise (e⁻ RMS)\ncamera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)  # 1.6 e⁻ RMS read noise\n\n# Run simulation with sCMOS camera\nparams = StaticSMLMParams(density=1.0, σ_psf=0.13)\nsmld_true, smld_model, smld_noisy = simulate(\n    params,\n    pattern=Nmer2D(n=8, d=0.1),\n    camera=camera_scmos\n)\n\n# Generate images with full sCMOS noise model\npsf = GaussianPSF(0.15)\nimages = gen_images(smld_model, psf, bg=10.0, camera_noise=true)\n\nThe sCMOS noise model applies these transformations in order:\n\nQuantum Efficiency (QE): Converts photons to photoelectrons (typically 70-95%)\nPoisson Noise: Shot noise on the photoelectron count\nRead Noise: Gaussian noise per pixel (amplifier/ADC noise)\nGain: Converts electrons to ADU (e.g., 0.5 e⁻/ADU)\nOffset: Adds dark level baseline (e.g., 100 ADU)","category":"section"},{"location":"images/#Advanced-sCMOS-Configuration","page":"Microscope Images","title":"Advanced sCMOS Configuration","text":"You can specify all calibration parameters explicitly:\n\ncamera_scmos = SCMOSCamera(\n    128, 128, 0.1;\n    offset=100.0,      # 100 ADU dark level\n    gain=0.5,          # 0.5 e⁻/ADU conversion\n    readnoise=1.6,     # 1.6 e⁻ RMS read noise\n    qe=0.95            # 95% quantum efficiency\n)\n\nEach parameter can be either:\n\nA scalar value (uniform across all pixels)\nA matrix (spatially varying, per-pixel calibration)","category":"section"},{"location":"images/#IdealCamera-vs-SCMOSCamera","page":"Microscope Images","title":"IdealCamera vs SCMOSCamera","text":"# IdealCamera: Use with poisson_noise for simple shot noise\ncamera_ideal = IdealCamera(128, 128, 0.1)\nsmld = BasicSMLD(emitters, camera_ideal, n_frames, n_datasets)\nimages_ideal = gen_images(smld, psf, bg=10.0, poisson_noise=true)\n\n# SCMOSCamera: Use with camera_noise for realistic noise\ncamera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)\nsmld = BasicSMLD(emitters, camera_scmos, n_frames, n_datasets)\nimages_scmos = gen_images(smld, psf, bg=10.0, camera_noise=true)\n\nwarning: Camera Type Compatibility\nThe camera_noise=true parameter only works with SCMOSCamera. Using it with IdealCamera will show a warning and be ignored. For IdealCamera, use poisson_noise=true instead.","category":"section"},{"location":"images/#Spatially-Varying-Calibration-Maps","page":"Microscope Images","title":"Spatially-Varying Calibration Maps","text":"Real sCMOS sensors have per-pixel variation in offset, gain, and readnoise. You can model this with calibration maps:\n\nusing SMLMSim\nusing MicroscopePSFs\n\n# Create per-pixel calibration maps (128×128 sensor)\nn_pixels = 128\n\n# Readnoise: mean 1.6 e⁻ with ±0.3 e⁻ variation\nreadnoise_map = 1.6 .+ 0.3 .* randn(n_pixels, n_pixels)\nreadnoise_map = max.(readnoise_map, 0.5)  # Ensure positive values\n\n# Offset: mean 100 ADU with ±5 ADU variation plus gradient\noffset_map = zeros(n_pixels, n_pixels)\nfor i in 1:n_pixels, j in 1:n_pixels\n    gradient = 10.0 * (i / n_pixels)  # Vertical gradient\n    noise = 5.0 * randn()\n    offset_map[i, j] = 100.0 + gradient + noise\nend\n\n# Gain: mostly uniform with slight pattern\ngain_map = 0.5 .+ 0.05 .* sin.(2π .* (1:n_pixels) ./ 20) * cos.(2π .* (1:n_pixels)' ./ 20)\n\n# Create sCMOS camera with spatially-varying calibration\npixel_size = 0.1  # 100 nm\ncamera_scmos = SCMOSCamera(\n    collect(0:pixel_size:(n_pixels*pixel_size)),\n    collect(0:pixel_size:(n_pixels*pixel_size)),\n    offset_map,\n    gain_map,\n    readnoise_map,\n    0.95  # Uniform quantum efficiency (could also be a matrix)\n)\n\n# Generate images with realistic spatial artifacts\n# (offset gradient, readnoise stripes, etc.)\nimages = gen_images(smld, psf, bg=10.0, camera_noise=true)\n\nThis creates realistic spatial artifacts visible in the images, including:\n\nOffset gradients: Fixed pattern across sensor\nReadnoise variation: Some pixels noisier than others\nGain non-uniformity: Affects signal scaling\n\nFor demonstration of extreme artifacts, see dev/scmos_quick_demo.jl in the repository.","category":"section"},{"location":"images/#PSF-Support-Region","page":"Microscope Images","title":"PSF Support Region","text":"The PSF support region controls how much of the PSF is calculated for each emitter, affecting both accuracy and performance. This parameter is specified in microns (μm):\n\n# Define a small support region (faster but may truncate PSF wings)\nimages = gen_images(smld_model, psf, support=3.0)  # 3.0 μm radius around each emitter\n\n# Define a rectangular support region\nimages = gen_images(smld_model, psf, support=(3.0, 3.0, 1.0, 1.0))  # (left, right, bottom, top) in μm\n\n# Use infinite support (most accurate but slowest)\nimages = gen_images(smld_model, psf, support=Inf)\n\nReducing the support region can significantly improve performance for large datasets at the cost of some accuracy. For most PSFs, a support radius of 3-5 times the PSF width (σ) is sufficient (typically 0.5-1.0 μm for a standard SMLM PSF).","category":"section"},{"location":"images/#Working-with-Image-Stacks","page":"Microscope Images","title":"Working with Image Stacks","text":"The generated images can be visualized using various Julia plotting libraries:\n\nusing CairoMakie  # or GLMakie, etc.\n\n# Display a single frame\nfig = Figure()\nax = Axis(fig[1, 1], yreversed=true)\nheatmap!(ax, images[:, :, 10]', colormap = :inferno)\ndisplay(fig)\n\n# Create and save a movie from all frames\nfig = Figure()\nax = Axis(fig[1, 1], yreversed=true)\n\n# record will clear and redraw each frame for you\nrecord(fig, \"smlm_simulation.mp4\", 1:size(images, 3); framerate = 10) do i\n    heatmap!(ax, images[:, :, i]', colormap = :inferno)\nend","category":"section"},{"location":"core/patterns/#Molecular-Patterns","page":"Patterns","title":"Molecular Patterns","text":"SMLMSim includes several built-in pattern types for positioning fluorophores in both 2D and 3D space. These patterns form the spatial foundation for simulating molecular structures.","category":"section"},{"location":"core/patterns/#Pattern-Hierarchy","page":"Patterns","title":"Pattern Hierarchy","text":"All patterns in SMLMSim inherit from these abstract types:\n\nPattern: Base type for all molecular patterns\nPattern2D: Base type for 2D patterns (x,y coordinates)\nPattern3D: Base type for 3D patterns (x,y,z coordinates)\n\nThis hierarchy enables specialized behavior while sharing common functionality.","category":"section"},{"location":"core/patterns/#2D-Patterns","page":"Patterns","title":"2D Patterns","text":"","category":"section"},{"location":"core/patterns/#Nmer2D","page":"Patterns","title":"Nmer2D","text":"The Nmer2D pattern creates N molecules arranged symmetrically in a circle of specified diameter.\n\n# Create an 8-molecule pattern with 100nm diameter (default)\nnmer = Nmer2D()\n\n# Create a custom pattern with 6 molecules and 200nm diameter\nhexamer = Nmer2D(n=6, d=0.2)  # d is in microns\n\nThis pattern is useful for simulating protein complexes, clusters, or other symmetric structures. The molecules are positioned equidistantly around a circle.","category":"section"},{"location":"core/patterns/#Line2D","page":"Patterns","title":"Line2D","text":"The Line2D pattern creates molecules arranged along a line segment with random positions.\n\n# Create a line with default parameters (10 molecules/μm between (-1,0) and (1,0))\nline = Line2D()\n\n# Create a custom line (5 molecules/μm between (-2,0) and (2,0))\ncustom_line = Line2D(λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])\n\nThe density parameter λ (lambda) specifies the average number of molecules per micron along the line. The actual number of molecules is drawn from a Poisson distribution.","category":"section"},{"location":"core/patterns/#3D-Patterns","page":"Patterns","title":"3D Patterns","text":"","category":"section"},{"location":"core/patterns/#Nmer3D","page":"Patterns","title":"Nmer3D","text":"The Nmer3D pattern is the 3D equivalent of Nmer2D, creating molecules in a circle at z=0.\n\n# Create an 8-molecule pattern with 100nm diameter (default)\nnmer3d = Nmer3D()\n\n# Create a custom pattern with 6 molecules and 200nm diameter\nhexamer3d = Nmer3D(n=6, d=0.2)","category":"section"},{"location":"core/patterns/#Line3D","page":"Patterns","title":"Line3D","text":"The Line3D pattern creates a 3D line with specified endpoints and density.\n\n# Default 3D line along x-axis\nline3d = Line3D()\n\n# Custom 3D line with specified endpoints and density\ncustom_line3d = Line3D(\n    λ=5.0,  # molecules per micron\n    endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)]\n)","category":"section"},{"location":"core/patterns/#Creating-Pattern-Distributions","page":"Patterns","title":"Creating Pattern Distributions","text":"Individual patterns define the arrangement of a single group of molecules. To create realistic samples, you'll typically want to distribute many instances of a pattern throughout the field of view.\n\nThe simulate() function handles this automatically with the density parameter ρ:\n\n# Simulate with 2 patterns per square micron\nsmld_true, smld_model, smld_noisy = simulate(\n    ρ=2.0,\n    pattern=Nmer2D(n=6, d=0.2)\n)\n\nBehind the scenes, this uses the uniform2D() or uniform3D() functions, which:\n\nGenerate a random number of patterns based on the density and field size\nPlace patterns randomly within the field of view\nApply random rotations to each pattern\nReturn the complete set of molecular coordinates\n\nFor advanced usage, you can access these functions directly:\n\n# Create custom distribution of 2D patterns\nfield_x = 10.0  # μm\nfield_y = 10.0  # μm\npattern = Nmer2D(n=6, d=0.2)\ndensity = 1.5   # patterns/μm²\n\nx, y = uniform2D(density, pattern, field_x, field_y)\n\n# Create custom distribution of 3D patterns\npattern3d = Nmer3D(n=6, d=0.2)\nx, y, z = uniform3D(density, pattern3d, field_x, field_y, zrange=[-2.0, 2.0])","category":"section"},{"location":"core/patterns/#Pattern-Manipulation","page":"Patterns","title":"Pattern Manipulation","text":"","category":"section"},{"location":"core/patterns/#Rotation","page":"Patterns","title":"Rotation","text":"You can rotate patterns before distributing them:\n\n# Rotate a 2D pattern by 45 degrees\nnmer = Nmer2D(n=8, d=0.1)\nrotate!(nmer, π/4)\n\n# Rotate a 3D pattern using Euler angles (ZYZ convention)\nnmer3d = Nmer3D(n=8, d=0.1)\nrotate!(nmer3d, π/4, π/6, π/3)  # α, β, γ angles in radians\n\n# Rotate a 3D pattern using a rotation matrix\nR = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]  # Z-axis rotation\nrotate!(nmer3d, R)","category":"section"},{"location":"core/patterns/#Custom-Patterns","page":"Patterns","title":"Custom Patterns","text":"You can create your own pattern types by:\n\nDefine a new struct that inherits from Pattern2D or Pattern3D\nImplement the necessary fields and constructors\nUse your custom pattern with the existing simulation framework\n\nExample:\n\n# Create a custom 2D grid pattern\nmutable struct Grid2D <: Pattern2D\n    nx::Int  # number of columns\n    ny::Int  # number of rows\n    dx::Float64  # column spacing\n    dy::Float64  # row spacing\n    x::Vector{Float64}\n    y::Vector{Float64}\nend\n\nfunction Grid2D(; nx=3, ny=3, dx=0.1, dy=0.1)\n    n = nx * ny\n    x = zeros(n)\n    y = zeros(n)\n    \n    idx = 1\n    for i in 1:nx, j in 1:ny\n        x[idx] = (i - (nx+1)/2) * dx\n        y[idx] = (j - (ny+1)/2) * dy\n        idx += 1\n    end\n    \n    return Grid2D(nx, ny, dx, dy, x, y)\nend\n\n# Use your custom pattern\ngrid = Grid2D(nx=4, ny=3, dx=0.1, dy=0.15)\nsmld_true, smld_model, smld_noisy = simulate(pattern=grid)","category":"section"},{"location":"static/examples/#Static-SMLM-Examples","page":"Examples","title":"Static SMLM Examples","text":"This page provides complete examples for using the static SMLM simulation capabilities of SMLMSim.","category":"section"},{"location":"static/examples/#Basic-2D-Simulation","page":"Examples","title":"Basic 2D Simulation","text":"This example demonstrates how to simulate and visualize a basic 2D SMLM dataset.\n\nusing SMLMSim\nusing CairoMakie\n\n# Create camera with physical pixel size\ncamera = IdealCamera(128, 64, 0.1)  # 128×64 pixels, 100nm pixels\n\n# Create simulation parameters\nparams = StaticSMLMParams(\n    density = 1.0,        # patterns per μm²\n    σ_psf = 0.13,         # PSF width in μm\n)\n\n# Run simulation with specified pattern and camera\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=Nmer2D(n=6, d=0.2),  # hexamer with 200nm diameter\n    camera=camera\n)\n\n# Extract coordinates and properties from emitters\nx_noisy = [e.x for e in smld_noisy.emitters]\ny_noisy = [e.y for e in smld_noisy.emitters]\nphotons = [e.photons for e in smld_noisy.emitters]\nframe_nums = [e.frame for e in smld_noisy.emitters]\n\n# Create figure for visualization\nfig = Figure(size=(900, 600))\n\n# Super-resolution scatter plot\nax1 = Axis(fig[1, 1], \n    title=\"Simulated SMLM Localizations\",\n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    aspect=DataAspect(),\n    yreversed=true  # Makes (0,0) at top-left\n)\n\n# Scatter plot with photon counts as color\nscatter!(ax1, x_noisy, y_noisy, \n    color=photons,\n    colormap=:viridis,\n    markersize=4,\n    alpha=0.6\n)\n\n# Return the figure\nfig\n","category":"section"},{"location":"static/examples/#3D-Simulation","page":"Examples","title":"3D Simulation","text":"This example shows how to create and visualize 3D SMLM data.\n\nusing SMLMSim\nusing CairoMakie\n\n# Create camera with physical pixel size\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\n\n# Create 3D simulation parameters\nparams = StaticSMLMParams(\n    density = 0.5,        # emitters per μm²\n    σ_psf = 0.13,         # PSF width in μm\n    ndims = 3,            # 3D simulation\n    zrange = [-1.0, 1.0]  # 2μm axial range\n)\n\n# Run 3D simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=Nmer3D(n=8, d=0.2),  # 3D pattern with 200nm diameter\n    camera=camera\n)\n\n# Extract 3D coordinates\nx = [e.x for e in smld_noisy.emitters]\ny = [e.y for e in smld_noisy.emitters]\nz = [e.z for e in smld_noisy.emitters]\nphotons = [e.photons for e in smld_noisy.emitters]\n\n# Create 3D visualization\nfig = Figure(size=(900, 700))\n\nax3d = Axis3(fig[1, 1], \n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    zlabel=\"z (μm)\",\n    title=\"3D SMLM Simulation\",\n    aspect = :data\n)\n\n# Plot localizations with z-dependent color\nscatter!(ax3d, x, y, z,\n    color=z,\n    colormap=:viridis,\n    markersize=5,\n    alpha=0.6\n)\n\nfig\n","category":"section"},{"location":"static/examples/#Generating-Microscope-Images","page":"Examples","title":"Generating Microscope Images","text":"This example shows how to generate synthetic microscope images from SMLM simulations:\n\nusing SMLMSim\nusing MicroscopePSFs\nusing CairoMakie\n\n# Create camera with physical pixel size\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\n\n# Create simulation parameters\nparams = StaticSMLMParams(\n    density = 2.0,        # patterns per μm²\n    σ_psf = 0.13,         # 130nm PSF width\n    nframes = 100,        # 100 frames\n    framerate = 20.0      # 20 fps\n)\n\n# Run simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=Nmer2D(n=6, d=0.2),  # hexamer with 200nm diameter\n    camera=camera\n)\n\n# Create a PSF model (Gaussian with 150nm width)\npsf = MicroscopePSFs.GaussianPSF(0.15)  # 150nm PSF width\n\n# Note: We use smld_model (not smld_noisy) to avoid double-counting uncertainty\n# smld_noisy already contains localization errors, and rendering camera images\n# naturally introduces noise, so using smld_noisy would apply noise twice\n# Generate image stack from emitter data with Poisson noise\nimages = gen_images(smld_model, psf;\n    bg=5.0,            # background photons per pixel\n    poisson_noise=true  # add realistic shot noise\n)\n\n# Display a single frame\nfig = Figure(size=(800, 400))\nax1 = Axis(fig[1, 1], \n    title=\"Simulated SMLM Image - Frame 20\",\n    aspect=DataAspect(),\n    yreversed=true\n)\n\n# Show the 20th frame with inferno colormap\nheatmap!(ax1, transpose(images[:, :, 20]), colormap=:inferno)\n\n# Also display emitters for this frame\nax2 = Axis(fig[1, 2], \n    title=\"Emitter Positions - Frame 20\",\n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    aspect=DataAspect()\n)\n\n# Extract emitters in frame 20\nframe20_emitters = filter(e -> e.frame == 20, smld_model.emitters)\nx = [e.x for e in frame20_emitters]\ny = [e.y for e in frame20_emitters]\nphotons = [e.photons for e in frame20_emitters]\n\n# Plot emitter positions\nscatter!(ax2, x, y, \n    color=photons,\n    colormap=:viridis,\n    markersize=10,\n    alpha=0.8\n)\n\n# Return the figure\nfig\n\n\nThe resulting images is a 3D array with dimensions [height, width, frames] that can be used for visualization, algorithm testing, or benchmarking localization software.","category":"section"},{"location":"static/examples/#Advanced:-Custom-Pattern","page":"Examples","title":"Advanced: Custom Pattern","text":"This example demonstrates creating a custom pattern type for simulation.\n\nusing SMLMSim\nusing CairoMakie\nusing Distributions\n\n# Define a custom pattern type: Grid with random jitter\nmutable struct JitteredGrid2D <: Pattern2D\n    n::Int       # Total number of molecules\n    nx::Int      # Columns\n    ny::Int      # Rows\n    dx::Float64  # Column spacing\n    dy::Float64  # Row spacing\n    jitter::Float64  # Random position jitter\n    x::Vector{Float64}  # x positions\n    y::Vector{Float64}  # y positions\nend\n\nfunction JitteredGrid2D(; nx=5, ny=5, dx=0.05, dy=0.05, jitter=0.01)\n    n = nx * ny\n    x = zeros(n)\n    y = zeros(n)\n    \n    idx = 1\n    for i in 1:nx, j in 1:ny\n        # Calculate regular grid position\n        grid_x = (i - (nx+1)/2) * dx\n        grid_y = (j - (ny+1)/2) * dy\n        \n        # Add random jitter\n        jitter_x = rand(Normal(0, jitter))\n        jitter_y = rand(Normal(0, jitter))\n        \n        # Store jittered position\n        x[idx] = grid_x + jitter_x\n        y[idx] = grid_y + jitter_y\n        idx += 1\n    end\n    \n    return JitteredGrid2D(n, nx, ny, dx, dy, jitter, x, y)\nend\n\n# Create camera\ncamera = IdealCamera(64, 64, 0.1)\n\n# Create custom pattern\ngrid = JitteredGrid2D()\n\n# Create simulation parameters\nparams = StaticSMLMParams(\n    density = 0.2,        # Patterns per μm²\n    nframes = 1000        # Number of frames\n)\n\n# Run simulation with custom pattern\nsmld_true, smld_model, smld_noisy = simulate(\n    params;\n    pattern=grid,\n    camera=camera\n)\n\n# Visualization\nfig = Figure(size=(800, 600))\n\n# Plot ground truth vs. noisy localizations\nax1 = Axis(fig[1, 1], \n    title=\"Ground Truth\",\n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    aspect=DataAspect()\n)\n\nax2 = Axis(fig[1, 2], \n    title=\"Noisy Localizations\",\n    xlabel=\"x (μm)\",\n    ylabel=\"y (μm)\",\n    aspect=DataAspect()\n)\n\n# Extract coordinates\nx_true = [e.x for e in smld_true.emitters]\ny_true = [e.y for e in smld_true.emitters]\n\nx_noisy = [e.x for e in smld_noisy.emitters]\ny_noisy = [e.y for e in smld_noisy.emitters]\nphotons = [e.photons for e in smld_noisy.emitters]\n\n# Plot\nscatter!(ax1, x_true, y_true, color=:black, markersize=6)\nscatter!(ax2, x_noisy, y_noisy, color=photons, colormap=:viridis, markersize=3, alpha=0.5)\n\n# Return the figure\nfig\n","category":"section"},{"location":"static/overview/#Static-SMLM-Simulation-Overview","page":"Overview","title":"Static SMLM Simulation Overview","text":"Static SMLM simulation creates fixed molecular patterns with realistic blinking kinetics and localization uncertainty. This approach is ideal for simulating structured biological samples like protein complexes, filaments, and other cellular structures.","category":"section"},{"location":"static/overview/#Simulation-Workflow","page":"Overview","title":"Simulation Workflow","text":"Static simulations follow this general workflow:\n\nPattern definition: Define molecular arrangements (e.g., oligomers, lines)\nPattern distribution: Distribute patterns throughout the field of view\nPhotophysics: Apply stochastic blinking behavior to each molecule\nLocalization uncertainty: Add realistic position errors based on photon counts","category":"section"},{"location":"static/overview/#Simulation-Parameters","page":"Overview","title":"Simulation Parameters","text":"Static simulations are configured using the StaticSMLMParams type:\n\n# Default parameters\nparams = StaticSMLMParams()\n\n# Custom parameters\nparams = StaticSMLMParams(\n    density=2.0,                # 2 patterns per μm²\n    σ_psf=0.15,           # 150nm PSF width\n    minphotons=100,       # Minimum photons for detection\n    ndatasets=5,          # Number of independent datasets\n    nframes=2000,         # Frames per dataset\n    framerate=100.0,      # Frames per second\n    ndims=3,              # 3D simulation\n    zrange=[-2.0, 2.0]    # 4μm axial range\n)","category":"section"},{"location":"static/overview/#Key-Parameters","page":"Overview","title":"Key Parameters","text":"density: Number of patterns per square micron\nσ_psf: Point spread function width in microns (impacts localization precision)\nminphotons: Minimum photons required for detection\nnframes: Number of frames in the simulation\nframerate: Frame rate in frames per second\nndims: Dimensionality (2 or 3)\nzrange: Axial range for 3D simulations","category":"section"},{"location":"static/overview/#Running-a-Simulation","page":"Overview","title":"Running a Simulation","text":"The high-level simulate() function provides a simple interface for static simulations:\n\n# Define a camera\ncamera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels\n\n# Run simulation with parameters\nsmld_true, smld_model, smld_noisy = simulate(\n    params,\n    pattern=Nmer2D(n=6, d=0.2),  # hexamer with 200nm diameter\n    molecule=GenericFluor(1e4, [-10.0 10.0; 0.5 -0.5]),  # fluorophore model\n    camera=camera\n)\n\nAlternatively, you can use keyword arguments directly:\n\nsmld_true, smld_model, smld_noisy = simulate(\n    density=1.0,                # patterns per μm²\n    σ_psf=0.13,           # PSF width in μm\n    nframes=1000,         # frames\n    framerate=50.0,       # frames per second\n    pattern=Nmer2D(n=8, d=0.1),  # pattern type\n    molecule=GenericFluor(1e4, [-10.0 10.0; 0.5 -0.5]), # γ=1e4, k_off=10, k_on=0.5\n    camera=camera\n)","category":"section"},{"location":"static/overview/#Understanding-Simulation-Results","page":"Overview","title":"Understanding Simulation Results","text":"The simulate() function returns three SMLD objects:\n\nsmld_true: Ground truth emitter positions\nContains the exact coordinates of all emitters\nSingle frame (no temporal information)\nNo blinking or noise applied\nsmld_model: Positions with blinking kinetics\nSubset of true positions appearing in different frames\nRealistic blinking behavior based on kinetic model\nNo position uncertainty (exact coordinates)\nsmld_noisy: Positions with blinking and localization uncertainty\nSame temporal distribution as smld_model\nPosition noise based on photon statistics\nMost comparable to real experimental data\n\nEach SMLD object contains emitters with properties like position, frame number, photon count, and uncertainties.","category":"section"},{"location":"static/overview/#Working-with-Results","page":"Overview","title":"Working with Results","text":"You can extract information from the simulation results for analysis or visualization:\n\n# Extract coordinates from noisy emitters\nx_noisy = [e.x for e in smld_noisy.emitters]\ny_noisy = [e.y for e in smld_noisy.emitters]\nphotons = [e.photons for e in smld_noisy.emitters]\nframes = [e.frame for e in smld_noisy.emitters]\n\n# Group emitters by original position using track_id\nemitters_by_position = Dict()\nfor e in smld_noisy.emitters\n    if !haskey(emitters_by_position, e.track_id)\n        emitters_by_position[e.track_id] = []\n    end\n    push!(emitters_by_position[e.track_id], e)\nend","category":"section"},{"location":"static/overview/#2D-vs-3D-Simulations","page":"Overview","title":"2D vs 3D Simulations","text":"The dimensionality of the simulation is controlled by both the ndims parameter and the pattern type:\n\n# 2D simulation\nparams = StaticSMLMParams(ndims=2)\npattern2d = Nmer2D(n=6, d=0.2)\nsmld_true_2d, smld_model_2d, smld_noisy_2d = simulate(params, pattern=pattern2d)\n\n# 3D simulation\nparams = StaticSMLMParams(ndims=3, zrange=[-2.0, 2.0])\npattern3d = Nmer3D(n=6, d=0.2)\nsmld_true_3d, smld_model_3d, smld_noisy_3d = simulate(params, pattern=pattern3d)\n\nFor 3D simulations, the localization uncertainty is automatically scaled in the axial dimension to reflect the typically lower z-resolution in SMLM experiments.","category":"section"},{"location":"#SMLMSim.jl","page":"Home","title":"SMLMSim.jl","text":"A Julia package for simulating Single Molecule Localization Microscopy (SMLM) data with realistic physical properties.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"SMLMSim provides tools for generating single molecule localization microscopy data with physically realistic properties, including:\n\nCustomizable spatial patterns of fluorophores in 2D and 3D\nRealistic fluorophore photophysics with stochastic kinetic models\nAccurate localization uncertainty based on photon counts\nDiffusion and interactions between molecules\nMicroscope image generation with configurable PSFs\n\nAll simulations use physical units, with coordinates in microns and time in seconds, allowing for direct comparison with experimental data.","category":"section"},{"location":"#Simulation-Types","page":"Home","title":"Simulation Types","text":"SMLMSim currently supports two main types of simulations:","category":"section"},{"location":"#Static-SMLM","page":"Home","title":"Static SMLM","text":"Static simulations generate fixed patterns of molecules (such as protein complexes or structures) with realistic blinking behavior and localization uncertainty. This approach is ideal for SMLM super-resolution applications including:\n\nSimulating structured samples (oligomers, filaments, etc.)\nTesting localization algorithms\nEvaluating super-resolution reconstruction methods\nBenchmarking SMLM analysis software","category":"section"},{"location":"#Diffusion-Interaction","page":"Home","title":"Diffusion-Interaction","text":"Diffusion simulations model the dynamic behavior of molecules undergoing Brownian motion, suitable for single particle tracking applications, including:\n\nFree diffusion with configurable coefficients\nFormation of molecular complexes (dimerization)\nDissociation of complexes\nCombined translational and rotational diffusion\n\nThis approach is ideal for studying dynamic biological processes and single-particle tracking applications.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SMLMSim\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Static-SMLM-Simulation","page":"Home","title":"Static SMLM Simulation","text":"using SMLMSim\n\n# Define a camera with 100nm pixel size\ncamera = IdealCamera(128, 128, 0.1)\n\n# Run a basic static simulation\nsmld_true, smld_model, smld_noisy = simulate(\n    density=1.0,                # 1 pattern per μm²\n    σ_psf=0.13,           # 130nm PSF width\n    pattern=Nmer2D(n=8, d=0.1),  # 8-molecule circular pattern (100nm diameter)\n    camera=camera\n)","category":"section"},{"location":"#Diffusion-Interaction-Simulation","page":"Home","title":"Diffusion-Interaction Simulation","text":"# Set diffusion simulation parameters\nparams = DiffusionSMLMParams(\n    density = 0.5,        # molecules per μm²\n    box_size = 10.0,      # μm\n    diff_monomer = 0.1,   # μm²/s\n    diff_dimer = 0.05,    # μm²/s\n    k_off = 0.2,          # s⁻¹\n    dt = 0.01,            # s\n    t_max = 10.0          # s\n)\n\n# Run diffusion simulation\nsmld_diffusion = simulate(params)","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"SMLMSim is built upon SMLMData.jl, reexporting essential types and functions so you typically don't need to import SMLMData directly.\n\nThe main components of the package are:\n\nPatterns: Spatial arrangements of molecules (Nmer2D, Line2D, etc.)\nMolecules: Photophysical models (e.g., GenericFluor)\nSimulation: Kinetic models and noise generation\nDiffusion: Smoluchowski dynamics for molecular interactions","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License - see the LICENSE file for details.","category":"section"},{"location":"core/noise/#Localization-Uncertainty","page":"Localization Uncertainty","title":"Localization Uncertainty","text":"This page explains how localization uncertainty is implemented in SMLMSim and how to customize it for realistic SMLM simulations.","category":"section"},{"location":"core/noise/#Overview","page":"Localization Uncertainty","title":"Overview","text":"In SMLM, localization uncertainty arises from:\n\nPhoton statistics: Finite photon counts lead to statistical errors in position estimation\nBackground noise: Reduces precision in determining the true position\nPixelation: Camera pixel size impacts the precision of measurements\nPSF model mismatch: Differences between actual and fitted PSF models\n\nSMLMSim primarily models the photon statistics component, which is typically the dominant source of uncertainty in SMLM.","category":"section"},{"location":"core/noise/#Theoretical-Basis","page":"Localization Uncertainty","title":"Theoretical Basis","text":"The fundamental limit of localization precision is given by the Cramér-Rao Lower Bound (CRLB). For a Gaussian PSF in the presence of background noise, the uncertainty in each dimension can be approximated as:\n\nsigma_textloc approx fracsigma_textPSFsqrtN\n\nWhere:\n\nsigma_textPSF\nis the width of the point spread function\nN\nis the number of photons detected from the emitter\n\nThis formula captures the key insight that localization precision improves with:\n\nMore photons (higher signal)\nSmaller PSF width","category":"section"},{"location":"core/noise/#Implementing-Uncertainty-in-SMLMSim","page":"Localization Uncertainty","title":"Implementing Uncertainty in SMLMSim","text":"SMLMSim applies localization uncertainty using the noise() function, which adds position errors based on photon counts:\n\n# Apply localization uncertainty to model with kinetic blinking\nsmld_noisy = noise(smld_model, 0.13)  # 0.13μm = 130nm PSF width\n\nFor 3D simulations, you specify the PSF width in each dimension:\n\n# Apply 3D localization uncertainty\nsmld_noisy_3d = noise(smld_model_3d, [0.13, 0.13, 0.39])  # [σx, σy, σz] in μm\n\nNote that the axial (z) uncertainty is typically 2-3× larger than the lateral (x,y) uncertainty.","category":"section"},{"location":"core/noise/#Uncertainty-in-Static-Simulations","page":"Localization Uncertainty","title":"Uncertainty in Static Simulations","text":"The StaticSMLMParams includes a parameter σ_psf that controls the PSF width used for uncertainty calculations:\n\n# Create simulation parameters with specific PSF width\nparams = StaticSMLMParams(\n    σ_psf=0.15,  # 150nm PSF width\n    ρ=1.0,       # 1 pattern per μm²\n    nframes=1000\n)\n\n# Run simulation\nsmld_true, smld_model, smld_noisy = simulate(params)\n\nThe third returned object (smld_noisy) contains emitters with:\n\nPosition noise added according to the PSF width and photon counts\nUncertainty fields (σ_x, σ_y, and for 3D σ_z) populated with the theoretical uncertainty values","category":"section"},{"location":"core/noise/#Accessing-Uncertainty-Values","page":"Localization Uncertainty","title":"Accessing Uncertainty Values","text":"You can access the uncertainty values for each emitter:\n\n# Get position uncertainties for all emitters\nσ_x_values = [e.σ_x for e in smld_noisy.emitters]\nσ_y_values = [e.σ_y for e in smld_noisy.emitters]\n\n# For 3D data\nσ_z_values = [e.σ_z for e in smld_noisy.emitters]\n\n# Plot relationship between photons and uncertainty\nusing CairoMakie\nphotons = [e.photons for e in smld_noisy.emitters]\nfig = Figure(size=(600, 400))\nax = Axis(fig[1, 1], \n    xlabel=\"Photons\", ylabel=\"σx (μm)\",\n    xscale=log10, yscale=log10,\n    title=\"Localization Uncertainty\")\nscatter!(ax, photons, σ_x_values)\nfig","category":"section"},{"location":"core/noise/#Customizing-Uncertainty-Models","page":"Localization Uncertainty","title":"Customizing Uncertainty Models","text":"","category":"section"},{"location":"core/noise/#PSF-Width","page":"Localization Uncertainty","title":"PSF Width","text":"The PSF width is the most important parameter affecting localization uncertainty:\n\n# Simulation with wider PSF (150nm)\nsmld_true, smld_model, smld_wide_psf = simulate(σ_psf=0.15)\n\n# Simulation with narrower PSF (100nm)\nsmld_true, smld_model, smld_narrow_psf = simulate(σ_psf=0.10)\n\nRealistic PSF widths depend on:\n\nWavelength (λ)\nNumerical aperture (NA)\nOptical aberrations\n\nFor visible light microscopy, typical values range from 100-250nm.","category":"section"},{"location":"core/noise/#Photon-Counts","page":"Localization Uncertainty","title":"Photon Counts","text":"The number of photons is controlled by:\n\nFluorophore emission rate: Set in the molecule model\nExposure time: Determined by the framerate\nDetection threshold: Set with minphotons\n\nusing SMLMSim\n\n# Define bright and dim fluorophores\n# Note: q matrices already had correct diagonal elements, just removed γ=\nbright_fluor = GenericFluor(5e4, [-5.0 5.0; 1.0 -1.0])\ndim_fluor = GenericFluor(5e3, [-5.0 5.0; 1.0 -1.0])\n\n# Bright emitters with lower uncertainty\nsmld_true, smld_model, smld_bright = simulate(molecule=bright_fluor)\n\n# Dim emitters with higher uncertainty\nsmld_true, smld_model, smld_dim = simulate(molecule=dim_fluor)","category":"section"}]
}
