<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SMLMSim.jl</title><meta name="title" content="API Reference · SMLMSim.jl"/><meta property="og:title" content="API Reference · SMLMSim.jl"/><meta property="twitter:title" content="API Reference · SMLMSim.jl"/><meta name="description" content="Documentation for SMLMSim.jl."/><meta property="og:description" content="Documentation for SMLMSim.jl."/><meta property="twitter:description" content="Documentation for SMLMSim.jl."/><meta property="og:url" content="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><meta property="twitter:url" content="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><link rel="canonical" href="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SMLMSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Core Components</span><ul><li><a class="tocitem" href="../core/patterns/">Patterns</a></li><li><a class="tocitem" href="../core/photophysics/">Photophysics</a></li><li><a class="tocitem" href="../core/noise/">Localization Uncertainty</a></li></ul></li><li><span class="tocitem">Static SMLM</span><ul><li><a class="tocitem" href="../static/overview/">Overview</a></li><li><a class="tocitem" href="../static/examples/">Examples</a></li></ul></li><li><span class="tocitem">Diffusion-Interaction</span><ul><li><a class="tocitem" href="../diffusion/overview/">Overview</a></li><li><a class="tocitem" href="../diffusion/examples/">Examples</a></li></ul></li><li><a class="tocitem" href="../images/">Microscope Images</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides a comprehensive reference for the types and functions in SMLMSim.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.SMLMSim" href="#SMLMSim.SMLMSim"><code>SMLMSim.SMLMSim</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SMLMSim</code></pre><p>Main module for the SMLMSim.jl package.</p><p>This package provides tools for simulating Single Molecule Localization Microscopy (SMLM) data. It includes modules for:</p><ul><li><strong>Core:</strong> Fundamental types (molecules, patterns) and photophysics simulation (CTMC, blinking).</li><li><strong>StaticSMLM:</strong> Simulating static emitters with blinking and localization noise.</li><li><strong>InteractionDiffusion:</strong> Simulating diffusing and interacting emitters (e.g., dimerization) using Smoluchowski dynamics.</li><li><strong>CameraImages:</strong> Generating simulated camera images from emitter data, including noise models.</li></ul><p>The main <code>SMLMSim</code> module re-exports key types and functions from these submodules to provide a unified user interface.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim

# Example: Static simulation
params_static = StaticSMLMParams(density=1.0, σ_psf=0.13)
_, _, smld_noisy = simulate(params_static)

# Example: Diffusion simulation
params_diff = DiffusionSMLMParams(density=0.5, diff_monomer=0.1)
smld_diff = simulate(params_diff)

# Example: Generate images
psf = GaussianPSF(0.15)
images = gen_images(smld_noisy, psf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/SMLMSim.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.simulate-Tuple{AbstractSim}" href="#SMLMSim.simulate-Tuple{AbstractSim}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(sim::AbstractSim; kwargs...)</code></pre><p>Generic interface for all simulation types. Dispatches to the appropriate method based on the concrete simulation type.</p><p><strong>Arguments</strong></p><ul><li><code>sim::AbstractSim</code>: The simulation configuration object</li><li><code>kwargs...</code>: Additional keyword arguments specific to the simulation type</li></ul><p><strong>Returns</strong></p><ul><li>The result of the specific simulation method</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a static SMLM simulation configuration
params = StaticSMLMParams(
    density = 1.0,        # Changed from ρ to density
    σ_psf = 0.13
)

# Run the simulation
results = simulate(params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/interface.jl#L14-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core" href="#SMLMSim.Core"><code>SMLMSim.Core</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Core</code></pre><p>Core module with shared utilities for SMLM simulation.</p><p>This module contains fundamental components that can be used across different simulation types (static, diffusion, etc.) including:</p><ol><li>Abstract types for simulation</li><li>Molecule and pattern definitions</li><li>CTMC (Continuous Time Markov Chain) for stochastic state transitions</li><li>Photophysics modeling for blinking kinetics and detection</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.Core</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/Core.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.AbstractSim" href="#SMLMSim.Core.AbstractSim"><code>SMLMSim.Core.AbstractSim</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSim</code></pre><p>Abstract type for all simulation types in SMLMSim. Concrete subtypes should implement their own simulate methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/abstract_types.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.CTMC" href="#SMLMSim.Core.CTMC"><code>SMLMSim.Core.CTMC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CTMC{T&lt;:AbstractFloat, U&lt;:Int}</code></pre><p>A Continuous Time Markov Chain representation storing the full trajectory of state transitions.</p><p><strong>Fields</strong></p><ul><li><code>simulation_time::T</code>: Total simulation time span</li><li><code>transition_times::Vector{T}</code>: Time points at which state changes occurred, starting at 0.0 </li><li><code>states::Vector{U}</code>: Sequence of states entered at each transition time, starting with initial state</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type for time values</li><li><code>U</code>: Integer type for state indices</li></ul><p><strong>Note</strong></p><p>The <code>states</code> and <code>transition_times</code> vectors have the same length, with each entry in <code>states[i]</code> representing the state entered at time <code>transition_times[i]</code>. The system remains in <code>states[i]</code>  until time <code>transition_times[i+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/ctmc.jl#L11-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.CTMC-Union{Tuple{T}, Tuple{Array{T}, T, Int64}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.CTMC-Union{Tuple{T}, Tuple{Array{T}, T, Int64}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.CTMC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CTMC(q::Array{T}, simulation_time::T, state1::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a Continuous Time Markov Chain simulation from a rate matrix.</p><p><strong>Arguments</strong></p><ul><li><code>q::Array{T}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i</li><li><code>simulation_time::T</code>: Total time to simulate</li><li><code>state1::Int</code>: Initial state</li></ul><p><strong>Returns</strong></p><ul><li><code>CTMC{T,Int}</code>: Simulated CTMC with transition times and states</li></ul><p><strong>Details</strong></p><p>Simulates a CTMC using the Gillespie algorithm:</p><ol><li>Start in state1 at time 0</li><li>For current state i:<ul><li>Calculate total exit rate k<em>tot = Σ</em>j q[i,j]</li><li>Sample time until next transition from Exp(k_tot)</li><li>Sample next state j with probability q[i,j]/k_tot</li></ul></li><li>Repeat until exceeding simulation_time</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/ctmc.jl#L64-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.GenericFluor" href="#SMLMSim.Core.GenericFluor"><code>SMLMSim.Core.GenericFluor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericFluor &lt;: Molecule</code></pre><p>Defines a fluorophore with photophysical properties.</p><p><strong>Fields</strong></p><ul><li><code>γ::AbstractFloat</code>: Photon emission rate in Hz. Default: 1e5</li><li><code>q::Array{&lt;:AbstractFloat}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i. Default: standard 2-state model with on-&gt;off rate of 50Hz and off-&gt;on rate of 1e-2Hz</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a fluorophore with default parameters (using the 2-state keyword constructor)
fluor = GenericFluor()

# Create a fluorophore with custom parameters using the positional constructor
fluor = GenericFluor(1e5, [-50.0 50.0; 1e-2 -1e-2])

# Create a fluorophore using the 2-state keyword constructor
fluor = GenericFluor(; photons=1e5, k_off=10.0, k_on=1e-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/molecules.jl#L11-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.GenericFluor-Tuple{}" href="#SMLMSim.Core.GenericFluor-Tuple{}"><code>SMLMSim.Core.GenericFluor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericFluor(; photons::AbstractFloat=1e5, k_off::AbstractFloat=50.0, k_on::AbstractFloat=1e-2)</code></pre><p>Create a simple two-state (on/off) fluorophore with specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>photons::AbstractFloat</code>: Photon emission rate in Hz</li><li><code>k_off::AbstractFloat</code>: Off-switching rate (on→off) in Hz</li><li><code>k_on::AbstractFloat</code>: On-switching rate (off→on) in Hz</li></ul><p><strong>Details</strong></p><p>Creates a fluorophore with a 2-state model and the specified rates. State 1 is the on (bright) state, and state 2 is the off (dark) state. The rate matrix is constructed as: q = [-k<em>off k</em>off; k<em>on -k</em>on]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/molecules.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Line2D" href="#SMLMSim.Core.Line2D"><code>SMLMSim.Core.Line2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Line2D &lt;: Pattern2D</code></pre><p>Points with uniform random distribution between two endpoints.</p><p><strong>Fields</strong></p><ul><li><code>λ::Float64</code>: Linear molecule density (molecules per micron)</li><li><code>endpoints::Vector{Tuple{Float64,Float64}}</code>: Vector of endpoint coordinates</li><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a line with default parameters
line = Line2D()

# Create a custom line
line = Line2D(; λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L148-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Line3D" href="#SMLMSim.Core.Line3D"><code>SMLMSim.Core.Line3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Line3D &lt;: Pattern3D</code></pre><p>Points with uniform random distribution between two 3D endpoints.</p><p><strong>Fields</strong></p><ul><li><code>λ::Float64</code>: Linear molecule density (molecules per micron)</li><li><code>endpoints::Vector{Tuple{Float64,Float64,Float64}}</code>: Vector of 3D endpoint coordinates</li><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li><li><code>z::Vector{Float64}</code>: Z positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a line with default parameters
line = Line3D()

# Create a custom 3D line
line = Line3D(; λ=5.0, endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L226-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Molecule" href="#SMLMSim.Core.Molecule"><code>SMLMSim.Core.Molecule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Molecule</code></pre><p>Abstract type for representing photophysical properties of a molecule.</p><p>This is the most general type of luminescent or scattering single molecule. Inherited types will define the properties of specific classes of molecules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/molecules.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Nmer2D" href="#SMLMSim.Core.Nmer2D"><code>SMLMSim.Core.Nmer2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nmer2D &lt;: Pattern2D</code></pre><p>N molecules symmetrically organized around a circle with diameter d.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>d::Float64</code>: Diameter of the circle in microns</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an 8-molecule pattern with 100nm diameter
nmer = Nmer2D()

# Create a custom pattern with 6 molecules and 200nm diameter
nmer = Nmer2D(; n=6, d=0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Nmer3D" href="#SMLMSim.Core.Nmer3D"><code>SMLMSim.Core.Nmer3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nmer3D &lt;: Pattern3D</code></pre><p>N molecules symmetrically organized around a circle with diameter d at z=0.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>d::Float64</code>: Diameter of the circle in microns</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li><li><code>z::Vector{Float64}</code>: Z positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an 8-molecule pattern with 100nm diameter
nmer = Nmer3D()

# Create a custom pattern with 6 molecules and 200nm diameter
nmer = Nmer3D(; n=6, d=0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L85-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Pattern" href="#SMLMSim.Core.Pattern"><code>SMLMSim.Core.Pattern</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Pattern</code></pre><p>Abstract type for all molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Pattern2D" href="#SMLMSim.Core.Pattern2D"><code>SMLMSim.Core.Pattern2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Pattern2D &lt;: Pattern</code></pre><p>Abstract type for 2D molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.Pattern3D" href="#SMLMSim.Core.Pattern3D"><code>SMLMSim.Core.Pattern3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Pattern3D &lt;: Pattern</code></pre><p>Abstract type for 3D molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.SMLMSimParams" href="#SMLMSim.Core.SMLMSimParams"><code>SMLMSim.Core.SMLMSimParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SMLMSimParams &lt;: AbstractSim</code></pre><p>Abstract type for all SMLM simulation parameter types. Provides a common parent for different types of SMLM simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/abstract_types.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.compute_equilibrium_distribution-Tuple{Matrix{&lt;:AbstractFloat}}" href="#SMLMSim.Core.compute_equilibrium_distribution-Tuple{Matrix{&lt;:AbstractFloat}}"><code>SMLMSim.Core.compute_equilibrium_distribution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_equilibrium_distribution(q::Matrix{&lt;:AbstractFloat})</code></pre><p>Calculate the equilibrium probability distribution for a CTMC rate matrix.</p><p><strong>Arguments</strong></p><ul><li><code>q::Matrix{&lt;:AbstractFloat}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Equilibrium probabilities for each state</li></ul><p><strong>Details</strong></p><p>For a rate matrix Q, the equilibrium distribution π satisfies π·Q = 0 subject to Σπ = 1. This function solves the linear system directly to find the equilibrium distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/photophysics.jl#L226-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.get_next-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.get_next-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.get_next</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_next(ctmc::CTMC, t::AbstractFloat)</code></pre><p>Get the next state transition after a specific time point.</p><p><strong>Arguments</strong></p><ul><li><code>ctmc::CTMC</code>: The CTMC to query</li><li><code>t::AbstractFloat</code>: Current time point</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int,AbstractFloat}</code>: (next<em>state, transition</em>time)</li></ul><p><strong>Note</strong></p><p>Returns the next state that will be entered and when it will be entered, searching from the current time point forward.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/ctmc.jl#L208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.get_num_tracks-Tuple{BasicSMLD}" href="#SMLMSim.Core.get_num_tracks-Tuple{BasicSMLD}"><code>SMLMSim.Core.get_num_tracks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_tracks(smld::BasicSMLD)</code></pre><p>Return the number of unique tracks (based on track_id) in the SMLD.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The SMLD to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of unique track IDs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get the number of tracks
n_tracks = get_num_tracks(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/track_utils.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.get_state-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.get_state-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.get_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_state(ctmc::CTMC, t::AbstractFloat)</code></pre><p>Get the state of the CTMC at a specific time point.</p><p><strong>Arguments</strong></p><ul><li><code>ctmc::CTMC</code>: The CTMC to query</li><li><code>t::AbstractFloat</code>: Time point of interest</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: State of the chain at time t</li></ul><p><strong>Note</strong></p><p>Searches through transition times to find the state active at time t. Returns the state that was entered at the last transition before t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/ctmc.jl#L182-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.get_track-Tuple{BasicSMLD, Int64}" href="#SMLMSim.Core.get_track-Tuple{BasicSMLD, Int64}"><code>SMLMSim.Core.get_track</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_track(smld::BasicSMLD, id::Int)</code></pre><p>Return a new SMLD containing only emitters with the specified track_id.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD</li><li><code>id::Int</code>: Track ID to filter by</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters from the specified track</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get all emitters belonging to track 5
track_smld = get_track(smld, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/track_utils.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.get_tracks-Tuple{BasicSMLD}" href="#SMLMSim.Core.get_tracks-Tuple{BasicSMLD}"><code>SMLMSim.Core.get_tracks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_tracks(smld::BasicSMLD)</code></pre><p>Return a vector of SMLD objects, one for each unique track (based on track_id).</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{BasicSMLD}</code>: Vector of SMLD objects, one per track</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get all tracks as separate SMLD objects
track_smlds = get_tracks(smld)

# Access the first track
first_track = track_smlds[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/track_utils.jl#L68-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.intensity_trace-Tuple{GenericFluor, Int64, Real}" href="#SMLMSim.Core.intensity_trace-Tuple{GenericFluor, Int64, Real}"><code>SMLMSim.Core.intensity_trace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intensity_trace(f::GenericFluor, nframes::Int, framerate::Real; state1=1)</code></pre><p>Calculate a fluorescence intensity trace by integrating emission during fluorescent state occupancy.</p><p><strong>Arguments</strong></p><ul><li><code>f::GenericFluor</code>: Fluorophore model containing transition rates (q) and emission rate (γ)</li><li><code>nframes::Int</code>: Number of frames to simulate</li><li><code>framerate::Real</code>: Frame rate in Hz</li><li><code>state1::Int=1</code>: Initial state (default: 1 for fluorescent state)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Integrated photon counts for each frame</li></ul><p><strong>Details</strong></p><p>For each frame:</p><ol><li>Determines state occupancy using CTMC</li><li>Integrates emission (rate f.γ) during fluorescent state periods</li><li>Accumulates photons within frame exposure time (1/framerate)</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">fluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])
photons = intensity_trace(fluor, 1000, 10.0)</code></pre><p><strong>Note</strong></p><ul><li>State 1 is assumed to be the fluorescent state</li><li>Emission only occurs in state 1 with rate f.γ</li><li>Frame exposure is assumed to be 1/framerate (100% duty cycle)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/photophysics.jl#L12-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.kinetic_model-Tuple{BasicSMLD, Molecule, Int64, Real}" href="#SMLMSim.Core.kinetic_model-Tuple{BasicSMLD, Molecule, Int64, Real}"><code>SMLMSim.Core.kinetic_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kinetic_model(smld::BasicSMLD, f::Molecule, nframes::Int, framerate::Real;
             ndatasets::Int=1, minphotons=50.0, state1::Int=2)</code></pre><p>Generate kinetic blinking model from existing localization data.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing true emitter positions</li><li><code>f::Molecule</code>: Fluorophore model with kinetic rates</li><li><code>nframes::Int</code>: Number of frames to simulate</li><li><code>framerate::Real</code>: Frame rate in Hz</li><li><code>ndatasets::Int=1</code>: Number of independent datasets to generate</li><li><code>minphotons::Float64=50.0</code>: Minimum photons for detection</li><li><code>state1::Union{Int, Symbol}=:equilibrium</code>: Initial state specification:<ul><li><code>::Int</code>: Specific state to start in (1=on, 2=off typically)</li><li><code>:equilibrium</code>: Sample from equilibrium distribution (default)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with simulated blinking kinetics</li></ul><p><strong>Details</strong></p><p>For each unique position in the input SMLD:</p><ol><li>Simulates fluorophore blinking using the kinetic model</li><li>Creates emitters for frames where photon count exceeds threshold</li><li>Preserves track_id for linking emitters from same position</li><li>Maintains camera and extends metadata from input SMLD</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">camera = IdealCamera(1:128, 1:128, 0.1)
pattern = Nmer2D()
smld_true, _, _ = simulate(pattern=pattern, camera=camera)

# Add blinking kinetics
fluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])
smld_model = kinetic_model(smld_true, fluor, 1000, 10.0)</code></pre><p><strong>Note</strong></p><p>The emitter type (2D/3D) is automatically determined from the input SMLD. Position uncertainties are initialized to 0 and can be set using the apply_noise() function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/photophysics.jl#L76-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern2D, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern2D, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern2D, θ::Float64)</code></pre><p>Rotate a 2D pattern by angle θ (in radians).</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern2D</code>: Pattern to rotate</li><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer2D()
rotate!(nmer, π/4)  # Rotate 45 degrees</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L440-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, Matrix{T}}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, Matrix{T}}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern3D, R::Matrix{Float64})</code></pre><p>Rotate a 3D pattern by rotation matrix R.</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern3D</code>: Pattern to rotate</li><li><code>R::Matrix{Float64}</code>: 3x3 rotation matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer3D()
# Create a rotation matrix for 90 degrees around z-axis
θ = π/2
R = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]
rotate!(nmer, R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L465-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, T, T, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, T, T, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern3D, α::Float64, β::Float64, γ::Float64)</code></pre><p>Rotate a 3D pattern by Euler angles α, β, γ (in radians). Uses ZYZ convention.</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern3D</code>: Pattern to rotate</li><li><code>α::Float64</code>: First rotation angle (around Z axis)</li><li><code>β::Float64</code>: Second rotation angle (around Y&#39; axis)</li><li><code>γ::Float64</code>: Third rotation angle (around Z&#39;&#39; axis)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer3D()
rotate!(nmer, π/4, π/6, π/3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L497-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.sample_discrete-Tuple{Vector{&lt;:AbstractFloat}}" href="#SMLMSim.Core.sample_discrete-Tuple{Vector{&lt;:AbstractFloat}}"><code>SMLMSim.Core.sample_discrete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_discrete(p::Vector{&lt;:AbstractFloat})</code></pre><p>Sample from a discrete probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>p::Vector{&lt;:AbstractFloat}</code>: Probability distribution</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Sampled state index</li></ul><p><strong>Details</strong></p><p>Samples a state index i with probability p[i] using the inverse CDF method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/photophysics.jl#L274-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.sample_discrete_with_probs-Tuple{Any, Any}" href="#SMLMSim.Core.sample_discrete_with_probs-Tuple{Any, Any}"><code>SMLMSim.Core.sample_discrete_with_probs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_discrete_with_probs(indices, probs)</code></pre><p>Sample a discrete value from indices with corresponding probabilities.</p><p><strong>Arguments</strong></p><ul><li><code>indices::Vector{Int}</code>: Vector of possible indices to sample</li><li><code>probs::Vector{&lt;:AbstractFloat}</code>: Corresponding probabilities</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Sampled index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/ctmc.jl#L158-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.uniform2D-Union{Tuple{T}, Tuple{T, Pattern2D, T, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.uniform2D-Union{Tuple{T}, Tuple{T, Pattern2D, T, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.uniform2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform2D(ρ::Float64, p::Pattern2D, field_x::Float64, field_y::Float64)</code></pre><p>Create coordinate arrays for randomly placed and rotated 2D patterns.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Float64</code>: Pattern density (patterns per square micron)</li><li><code>p::Pattern2D</code>: Pattern to replicate</li><li><code>field_x::Float64</code>: Field width in microns</li><li><code>field_y::Float64</code>: Field height in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}}</code>: (x, y) coordinates in microns</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate coordinates for randomly placed Nmer2D patterns
nmer = Nmer2D(; n=6, d=0.2)
x, y = uniform2D(1.0, nmer, 10.0, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L314-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.Core.uniform3D-Union{Tuple{T}, Tuple{T, Pattern3D, T, T}} where T&lt;:AbstractFloat" href="#SMLMSim.Core.uniform3D-Union{Tuple{T}, Tuple{T, Pattern3D, T, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.uniform3D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform3D(ρ::Float64, p::Pattern3D, field_x::Float64, field_y::Float64; 
         zrange::Vector{Float64}=[-1.0, 1.0])</code></pre><p>Create coordinate arrays for randomly placed and rotated 3D patterns.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Float64</code>: Pattern density (patterns per square micron)</li><li><code>p::Pattern3D</code>: Pattern to replicate</li><li><code>field_x::Float64</code>: Field width in microns</li><li><code>field_y::Float64</code>: Field height in microns</li><li><code>zrange::Vector{Float64}=[-1.0, 1.0]</code>: [min<em>z, max</em>z] range in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}</code>: (x, y, z) coordinates</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate coordinates for randomly placed Nmer3D patterns
nmer = Nmer3D(; n=6, d=0.2)
x, y, z = uniform3D(1.0, nmer, 10.0, 10.0; zrange=[-2.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/core/patterns.jl#L361-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.StaticSMLM" href="#SMLMSim.StaticSMLM"><code>SMLMSim.StaticSMLM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticSMLM</code></pre><p>Module for simulating static (non-diffusing) SMLM data with blinking kinetics.</p><p>This module provides functionality for:</p><ol><li>Generating spatial distributions of emitters based on patterns</li><li>Simulating fluorophore blinking based on stochastic kinetic models</li><li>Adding realistic localization uncertainties</li><li>Creating complete SMLM datasets</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.StaticSMLM</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/StaticSMLM.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.StaticSMLM.StaticSMLMParams" href="#SMLMSim.StaticSMLM.StaticSMLMParams"><code>SMLMSim.StaticSMLM.StaticSMLMParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticSMLMParams &lt;: SMLMSimParams</code></pre><p>Parameters for static SMLM simulation.</p><p><strong>Fields</strong></p><ul><li><code>density::Float64</code>: density in particles per square micron</li><li><code>σ_psf::Float64</code>: PSF width in microns</li><li><code>minphotons::Int</code>: minimum photons for detection</li><li><code>ndatasets::Int</code>: number of datasets to simulate</li><li><code>nframes::Int</code>: number of frames per dataset</li><li><code>framerate::Float64</code>: frames per second</li><li><code>ndims::Int</code>: dimensionality (2 or 3)</li><li><code>zrange::Vector{Float64}</code>: axial range for 3D simulations [min<em>z, max</em>z]</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default parameters
params = StaticSMLMParams()

# Custom parameters
params = StaticSMLMParams(
    density = 2.0,              # 2 particles per μm²
    σ_psf = 0.15,         # 150nm PSF width
    minphotons = 100,     # minimum photons for detection
    ndatasets = 5,        # 5 independent datasets
    nframes = 2000,       # 2000 frames per dataset
    framerate = 100.0,    # 100 frames per second
    ndims = 3,            # 3D simulation
    zrange = [-2.0, 2.0]  # 4μm axial range
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/parameters.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.StaticSMLM.add_coordinate_noise-Tuple{Emitter2DFit, AbstractFloat}" href="#SMLMSim.StaticSMLM.add_coordinate_noise-Tuple{Emitter2DFit, AbstractFloat}"><code>SMLMSim.StaticSMLM.add_coordinate_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_coordinate_noise(emitter, σ)</code></pre><p>Helper function to add position noise to an emitter with appropriate uncertainty. Returns new coordinate values and uncertainty values.</p><p>For 2D emitters, σ is a scalar. For 3D emitters, σ is a 3-element vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/coordinate_noise.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, AbstractFloat}" href="#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, AbstractFloat}"><code>SMLMSim.StaticSMLM.apply_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_noise(smld::BasicSMLD, σ_psf::AbstractFloat)</code></pre><p>Add localization uncertainty to 2D emitter positions based on photon counts.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing 2D emitters</li><li><code>σ_psf::AbstractFloat</code>: PSF width in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with noisy positions and updated uncertainties</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Then add localization noise with specific PSF width
smld_noisy = apply_noise(smld_model, 0.13)  # 130nm PSF width</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/coordinate_noise.jl#L40-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, Vector{&lt;:AbstractFloat}}" href="#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, Vector{&lt;:AbstractFloat}}"><code>SMLMSim.StaticSMLM.apply_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_noise(smld::BasicSMLD, σ_psf::Vector{&lt;:AbstractFloat})</code></pre><p>Add localization uncertainty to 3D emitter positions based on photon counts.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing 3D emitters</li><li><code>σ_psf::Vector{&lt;:AbstractFloat}</code>: PSF widths [σx, σy, σz] in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with noisy positions and updated uncertainties</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Then add localization noise with specific PSF widths
σ_psf = [0.13, 0.13, 0.39]  # 130nm lateral, 390nm axial
smld_noisy = apply_noise(smld_model, σ_psf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/coordinate_noise.jl#L102-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.simulate-Tuple{StaticSMLMParams}" href="#SMLMSim.simulate-Tuple{StaticSMLMParams}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(params::StaticSMLMParams; 
         starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractEmitter}}=nothing,
         pattern::Pattern=nothing,
         molecule::Molecule=GenericFluor(photons=1e4, k_off=50.0, k_on=1e-2),
         camera::AbstractCamera=IdealCamera(1:128, 1:128, 0.1))</code></pre><p>Generate simulated static SMLM data with realistic blinking kinetics and localization uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>params::StaticSMLMParams</code>: Simulation parameters</li><li><code>starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractEmitter}}</code>: Optional starting conditions instead of generating patterns</li><li><code>pattern::Pattern</code>: Pattern to use (default depends on params.ndims)</li><li><code>molecule::Molecule</code>: Fluorophore model for blinking simulation</li><li><code>camera::AbstractCamera</code>: Camera model for detection simulation</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{BasicSMLD, BasicSMLD, BasicSMLD}</code>: (true<em>positions, model</em>kinetics, noisy_data)<ul><li>true_positions: Ground truth emitter positions</li><li>model_kinetics: Positions with simulated blinking</li><li>noisy_data: Positions with blinking and localization uncertainty</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create parameters
params = StaticSMLMParams(
    density = 2.0,              # 2 patterns per μm²
    σ_psf = 0.15,         # 150nm PSF width
    minphotons = 100,     # 100 photons for detection
    ndatasets = 5,        # 5 independent datasets
    nframes = 2000,       # 2000 frames
    framerate = 100.0     # 100 frames per second
)

# Run simulation with Nmer pattern
pattern = Nmer3D(n=6, d=0.2)
smld_true, smld_model, smld_noisy = simulate(params; pattern=pattern)

# Run with custom starting conditions
custom_emitters = [
    Emitter2DFit{Float64}(x, y, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0; track_id=i)
    for (i, (x, y)) in enumerate(zip(rand(10), rand(10)))
]
smld_true, smld_model, smld_noisy = simulate(params; starting_conditions=custom_emitters)</code></pre><p><strong>Note</strong></p><ul><li>The <code>params.σ_psf</code> value is used directly for lateral uncertainty (σx, σy) in both 2D and 3D.</li><li>For 3D simulations, the axial uncertainty (σz) is scaled by a factor of 3 (i.e., σz = 3 * σ_psf).</li><li>If <code>starting_conditions</code> is provided, it will be used instead of generating patterns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/static/simulation.jl#L5-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion" href="#SMLMSim.InteractionDiffusion"><code>SMLMSim.InteractionDiffusion</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InteractionDiffusion</code></pre><p>This module provides simulation tools for diffusion and interaction between particles.</p><p><strong>Overview</strong></p><p>Simulates diffusion and interaction dynamics between particles in 2D/3D space. Includes functionality for generating microscope images, analyzing dimers, and visualizing particle dynamics.</p><p><strong>Components</strong></p><ul><li>Abstract and concrete emitter types (AbstractDiffusingEmitter, DiffusingEmitter2D, DiffusingEmitter3D)</li><li>Smoluchowski dynamics simulation</li><li>Analysis tools for dimers and state transitions</li><li>SMLD conversion utilities</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set up simulation parameters
params = DiffusionSMLMParams(
    density = 0.5,            # molecules per μm²
    box_size = 10.0,          # μm
    diff_monomer = 0.1,       # μm²/s
    diff_dimer = 0.05,        # μm²/s
    k_off = 0.2,              # s⁻¹
    r_react = 0.01,           # μm
    d_dimer = 0.05,           # μm
    dt = 0.01,                # s
    t_max = 10.0,             # s
    camera_framerate = 20.0,  # fps
    camera_exposure = 0.04    # s
)

# Run simulation - returns a single SMLD with all emitters
smld = simulate(params)

# Generate images for microscopy
psf = GaussianPSF(0.15)  # 150nm PSF width
images = gen_images(psf, smld)

# Analyze results
dimer_smld = get_dimers(smld)
frames, dimer_fractions = analyze_dimer_fraction(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/InteractionDiffusion.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter" href="#SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter"><code>SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDiffusingEmitter &lt;: AbstractEmitter</code></pre><p>Abstract type for all diffusing emitters to enable dispatch-based operations. This provides a common parent for 2D and 3D diffusing emitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/types.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.DiffusingEmitter2D" href="#SMLMSim.InteractionDiffusion.DiffusingEmitter2D"><code>SMLMSim.InteractionDiffusion.DiffusingEmitter2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiffusingEmitter2D{T&lt;:AbstractFloat} &lt;: AbstractDiffusingEmitter</code></pre><p>A 2D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: x-coordinate in microns</li><li><code>y::T</code>: y-coordinate in microns</li><li><code>photons::T</code>: number of photons emitted</li><li><code>timestamp::T</code>: actual simulation time in seconds</li><li><code>frame::Int</code>: camera frame number based on framerate and exposure</li><li><code>dataset::Int</code>: dataset identifier</li><li><code>track_id::Int</code>: unique molecule identifier </li><li><code>state::Symbol</code>: molecular state (:monomer or :dimer)</li><li><code>partner_id::Union{Int,Nothing}</code>: ID of linked molecule (for dimers), or nothing for monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/types.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.DiffusingEmitter3D" href="#SMLMSim.InteractionDiffusion.DiffusingEmitter3D"><code>SMLMSim.InteractionDiffusion.DiffusingEmitter3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiffusingEmitter3D{T&lt;:AbstractFloat} &lt;: AbstractDiffusingEmitter</code></pre><p>A 3D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: x-coordinate in microns</li><li><code>y::T</code>: y-coordinate in microns</li><li><code>z::T</code>: z-coordinate in microns</li><li><code>photons::T</code>: number of photons emitted</li><li><code>timestamp::T</code>: actual simulation time in seconds</li><li><code>frame::Int</code>: camera frame number based on framerate and exposure</li><li><code>dataset::Int</code>: dataset identifier</li><li><code>track_id::Int</code>: unique molecule identifier</li><li><code>state::Symbol</code>: molecular state (:monomer or :dimer)</li><li><code>partner_id::Union{Int,Nothing}</code>: ID of linked molecule (for dimers), or nothing for monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/types.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.DiffusionSMLMParams" href="#SMLMSim.InteractionDiffusion.DiffusionSMLMParams"><code>SMLMSim.InteractionDiffusion.DiffusionSMLMParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiffusionSMLMParams &lt;: SMLMSimParams</code></pre><p>Parameters for diffusion-based SMLM simulation using Smoluchowski dynamics.</p><p><strong>Fields</strong></p><ul><li><code>density::Float64</code>: number density (molecules/μm²)</li><li><code>box_size::Float64</code>: simulation box size (μm)</li><li><code>diff_monomer::Float64</code>: monomer diffusion coefficient (μm²/s)</li><li><code>diff_dimer::Float64</code>: dimer diffusion coefficient (μm²/s)</li><li><code>diff_dimer_rot::Float64</code>: dimer rotational diffusion coefficient (rad²/s)</li><li><code>k_off::Float64</code>: dimer dissociation rate (s⁻¹)</li><li><code>r_react::Float64</code>: reaction radius (μm)</li><li><code>d_dimer::Float64</code>: monomer separation in dimer (μm)</li><li><code>dt::Float64</code>: time step (s)</li><li><code>t_max::Float64</code>: total simulation time (s)</li><li><code>ndims::Int</code>: number of dimensions (2 or 3)</li><li><code>boundary::String</code>: boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li><li><code>camera_framerate::Float64</code>: camera frames per second (Hz)</li><li><code>camera_exposure::Float64</code>: camera exposure time per frame (s)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default parameters
params = DiffusionSMLMParams()

# Custom parameters
params = DiffusionSMLMParams(
    density = 1.0,           # 1 molecule per μm²
    box_size = 20.0,         # 20μm × 20μm box
    diff_monomer = 0.2,      # 0.2 μm²/s
    diff_dimer = 0.1,        # 0.1 μm²/s
    diff_dimer_rot = 0.8,    # 0.8 rad²/s
    k_off = 0.1,             # 0.1 s⁻¹
    r_react = 0.02,          # 20nm reaction radius
    d_dimer = 0.06,          # 60nm dimer separation
    dt = 0.005,              # 5ms time step
    t_max = 20.0,            # 20s simulation
    ndims = 3,               # 3D simulation
    boundary = &quot;reflecting&quot;, # reflecting boundaries
    camera_framerate = 20.0, # 20 frames per second
    camera_exposure = 0.04   # 40ms exposure per frame
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Union{Tuple{DiffusingEmitter2D{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Base.copy-Union{Tuple{DiffusingEmitter2D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(e::DiffusingEmitter2D)</code></pre><p>Create a copy of a 2D diffusing emitter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/types.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Union{Tuple{DiffusingEmitter3D{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Base.copy-Union{Tuple{DiffusingEmitter3D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(e::DiffusingEmitter3D)</code></pre><p>Create a copy of a 3D diffusing emitter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/types.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.add_camera_frame_emitters!-Tuple{Any, Any, Any, Any, DiffusionSMLMParams}" href="#SMLMSim.InteractionDiffusion.add_camera_frame_emitters!-Tuple{Any, Any, Any, Any, DiffusionSMLMParams}"><code>SMLMSim.InteractionDiffusion.add_camera_frame_emitters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_camera_frame_emitters!(camera_emitters, emitters, time, frame_num, params)</code></pre><p>Add emitters to camera frames when they fall within an exposure window.</p><p><strong>Arguments</strong></p><ul><li><code>camera_emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Collection of emitters for camera frames</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Current emitters from simulation</li><li><code>time::Float64</code>: Current simulation time</li><li><code>frame_num::Int</code>: Current frame number</li><li><code>params::DiffusionSMLMParams</code>: Simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L286-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.analyze_dimer_fraction-Tuple{BasicSMLD}" href="#SMLMSim.InteractionDiffusion.analyze_dimer_fraction-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.analyze_dimer_fraction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_dimer_fraction(smld::BasicSMLD)</code></pre><p>Calculate the fraction of dimers per frame.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Int}, Vector{Float64}}</code>: Frame numbers and dimer fractions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Calculate dimer fraction over time
frames, fractions = analyze_dimer_fraction(smld)
plot(frames, fractions, xlabel=&quot;Frame&quot;, ylabel=&quot;Dimer Fraction&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L100-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.analyze_dimer_lifetime-Tuple{BasicSMLD}" href="#SMLMSim.InteractionDiffusion.analyze_dimer_lifetime-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.analyze_dimer_lifetime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_dimer_lifetime(smld::BasicSMLD)</code></pre><p>Calculate the average lifetime of dimers.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Average dimer lifetime in seconds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L201-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.apply_boundary-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, String}" href="#SMLMSim.InteractionDiffusion.apply_boundary-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, String}"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_boundary(e::AbstractDiffusingEmitter, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to an emitter (generic fallback).</p><p><strong>Arguments</strong></p><ul><li><code>e::AbstractDiffusingEmitter</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractDiffusingEmitter</code>: Emitter with boundary conditions applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L543-L555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, String}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, String}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_boundary(e::DiffusingEmitter2D, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to a 2D emitter.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter2D</code>: New emitter with position constrained to the box</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L560-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, String}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, String}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_boundary(e::DiffusingEmitter3D, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to a 3D emitter.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter3D</code>: New emitter with position constrained to the box</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L611-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.can_dimerize-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64}" href="#SMLMSim.InteractionDiffusion.can_dimerize-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64}"><code>SMLMSim.InteractionDiffusion.can_dimerize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">can_dimerize(e1::AbstractDiffusingEmitter, e2::AbstractDiffusingEmitter, r_react::Float64)</code></pre><p>Check if two emitters can form a dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e1::AbstractDiffusingEmitter</code>: First emitter</li><li><code>e2::AbstractDiffusingEmitter</code>: Second emitter</li><li><code>r_react::Float64</code>: Reaction radius in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: True if emitters can form a dimer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters" href="#SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters"><code>SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_to_diffusing_emitters(emitters::Vector{&lt;:AbstractEmitter}, photons::Float64=1000.0, state::Symbol=:monomer)</code></pre><p>Convert regular emitters to diffusing emitters for use as starting conditions.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractEmitter}</code>: Vector of static emitters to convert</li><li><code>photons::Float64=1000.0</code>: Number of photons to assign</li><li><code>state::Symbol=:monomer</code>: Initial state (:monomer or :dimer)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Vector of diffusing emitters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Convert static emitters to diffusing emitters
static_emitters = smld_static.emitters
diffusing_emitters = convert_to_diffusing_emitters(static_emitters)

# Use as starting conditions for a diffusion simulation
params = DiffusionSMLMParams(t_max=10.0)
smld = simulate(params; starting_conditions=diffusing_emitters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L478-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.create_smld-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, SMLMData.AbstractCamera, DiffusionSMLMParams}" href="#SMLMSim.InteractionDiffusion.create_smld-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, SMLMData.AbstractCamera, DiffusionSMLMParams}"><code>SMLMSim.InteractionDiffusion.create_smld</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_smld(emitters::Vector{&lt;:AbstractDiffusingEmitter}, camera::AbstractCamera, params::DiffusionSMLMParams)</code></pre><p>Convert a collection of diffusing emitters to a BasicSMLD object.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Collection of emitters from simulation</li><li><code>camera::AbstractCamera</code>: Camera model for imaging</li><li><code>params::DiffusionSMLMParams</code>: Simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: SMLD containing all emitters for further analysis or visualization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L671-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, Float64}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffuse(e::DiffusingEmitter2D, diff_coef::Float64, dt::Float64)</code></pre><p>Create a new emitter with updated position based on Brownian motion.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter to update</li><li><code>diff_coef::Float64</code>: Diffusion coefficient (μm²/s)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter2D</code>: New emitter with updated position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L337-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, Float64}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffuse(e::DiffusingEmitter3D, diff_coef::Float64, dt::Float64)</code></pre><p>Create a new 3D emitter with updated position based on Brownian motion.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter to update</li><li><code>diff_coef::Float64</code>: Diffusion coefficient (μm²/s)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter3D</code>: New emitter with updated position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L370-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse_dimer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffuse_dimer(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)</code></pre><p>Diffuse a dimer with both translational and rotational components.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter2D</code>: First emitter in dimer</li><li><code>e2::DiffusingEmitter2D</code>: Second emitter in dimer</li><li><code>diff_trans::Float64</code>: Translational diffusion coefficient (μm²/s)</li><li><code>diff_rot::Float64</code>: Rotational diffusion coefficient (rad²/s)</li><li><code>d_dimer::Float64</code>: Dimer separation distance (μm)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters with updated positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L404-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse_dimer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffuse_dimer(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)</code></pre><p>Diffuse a 3D dimer with both translational and rotational components.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter3D</code>: First emitter in dimer</li><li><code>e2::DiffusingEmitter3D</code>: Second emitter in dimer</li><li><code>diff_trans::Float64</code>: Translational diffusion coefficient (μm²/s)</li><li><code>diff_rot::Float64</code>: Rotational diffusion coefficient (rad²/s)</li><li><code>d_dimer::Float64</code>: Dimer separation distance (μm)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters with updated positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L470-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Float64}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dimerize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimerize(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, d_dimer::Float64)</code></pre><p>Create two new emitters in dimer state from two monomers.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter2D</code>: First emitter</li><li><code>e2::DiffusingEmitter2D</code>: Second emitter</li><li><code>d_dimer::Float64</code>: Dimer separation distance in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters in dimer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Float64}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dimerize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimerize(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, d_dimer::Float64)</code></pre><p>Create two new emitters in dimer state from two monomers in 3D.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter3D</code>: First emitter</li><li><code>e2::DiffusingEmitter3D</code>: Second emitter</li><li><code>d_dimer::Float64</code>: Dimer separation distance in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters in dimer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L163-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dissociate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dissociate(e::DiffusingEmitter2D, emitters::Vector{&lt;:AbstractDiffusingEmitter})</code></pre><p>Create two new monomers from a dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter part of a dimer</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: All emitters in the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters in monomer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L234-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat" href="#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dissociate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dissociate(e::DiffusingEmitter3D, emitters::Vector{&lt;:AbstractDiffusingEmitter})</code></pre><p>Create two new monomers from a 3D dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter part of a dimer</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: All emitters in the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters in monomer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L285-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.extract_final_state-Tuple{SMLMData.SMLD}" href="#SMLMSim.InteractionDiffusion.extract_final_state-Tuple{SMLMData.SMLD}"><code>SMLMSim.InteractionDiffusion.extract_final_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_final_state(smld::SMLD)</code></pre><p>Extract the emitters from the final frame of a simulation to use as starting conditions.</p><p><strong>Arguments</strong></p><ul><li><code>smld::SMLD</code>: SMLD containing emitters from a simulation</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractEmitter}</code>: Emitters from the final frame</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run a simulation
params = DiffusionSMLMParams(t_max=5.0)
smld = simulate(params)

# Extract final state
final_state = extract_final_state(smld)

# Continue simulation with new parameters
params_new = DiffusionSMLMParams(t_max=10.0, diff_monomer=0.2)
smld_continued = simulate(params_new; starting_conditions=final_state)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L540-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.filter_by_state-Tuple{BasicSMLD, Symbol}" href="#SMLMSim.InteractionDiffusion.filter_by_state-Tuple{BasicSMLD, Symbol}"><code>SMLMSim.InteractionDiffusion.filter_by_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_by_state(smld::BasicSMLD, state::Symbol)</code></pre><p>Filter emitters by their state (monomer or dimer).</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD with diffusing emitters</li><li><code>state::Symbol</code>: State to filter by (:monomer or :dimer)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters with the specified state</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get only monomers
monomer_smld = filter_by_state(smld, :monomer)

# Get only dimers
dimer_smld = filter_by_state(smld, :dimer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.get_dimers-Tuple{BasicSMLD}" href="#SMLMSim.InteractionDiffusion.get_dimers-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.get_dimers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dimers(smld::BasicSMLD)</code></pre><p>Extract a new BasicSMLD containing only emitters in dimer state.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Original SMLD with all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only dimers</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Extract only dimers from simulation results
smld = simulate(params)
dimer_smld = get_dimers(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L8-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.get_frame-Tuple{BasicSMLD, Int64}" href="#SMLMSim.InteractionDiffusion.get_frame-Tuple{BasicSMLD, Int64}"><code>SMLMSim.InteractionDiffusion.get_frame</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_frame(smld::BasicSMLD, frame_num::Int)</code></pre><p>Extract emitters from a specific frame.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li><li><code>frame_num::Int</code>: Frame number to extract</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters from the specified frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L706-L717">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.get_monomers-Tuple{BasicSMLD}" href="#SMLMSim.InteractionDiffusion.get_monomers-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.get_monomers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_monomers(smld::BasicSMLD)</code></pre><p>Extract a new BasicSMLD containing only emitters in monomer state.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Original SMLD with all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L40-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.initialize_emitters" href="#SMLMSim.InteractionDiffusion.initialize_emitters"><code>SMLMSim.InteractionDiffusion.initialize_emitters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_emitters(params::DiffusionSMLMParams, photons::Float64=1000.0; override_count::Union{Nothing, Int}=nothing)</code></pre><p>Create initial emitter positions for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>params::DiffusionSMLMParams</code>: Simulation parameters</li><li><code>photons::Float64=1000.0</code>: Number of photons per emitter</li><li><code>override_count::Union{Nothing, Int}=nothing</code>: Optional override for the number of molecules</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Vector of initialized emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.should_dissociate-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, Float64}" href="#SMLMSim.InteractionDiffusion.should_dissociate-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, Float64}"><code>SMLMSim.InteractionDiffusion.should_dissociate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">should_dissociate(e::AbstractDiffusingEmitter, k_off::Float64, dt::Float64)</code></pre><p>Check if a dimer should dissociate based on stochastic rate.</p><p><strong>Arguments</strong></p><ul><li><code>e::AbstractDiffusingEmitter</code>: Emitter to check</li><li><code>k_off::Float64</code>: Dissociation rate (s⁻¹)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: True if dimer should dissociate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/helpers.jl#L217-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.track_state_changes-Tuple{BasicSMLD}" href="#SMLMSim.InteractionDiffusion.track_state_changes-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.track_state_changes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">track_state_changes(smld::BasicSMLD)</code></pre><p>Track state changes of molecules over time.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Vector{Tuple{Int, Symbol}}}</code>: Dictionary mapping molecule IDs to vectors of (frame, state) pairs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Track state changes of molecules
state_history = track_state_changes(smld)

# Plot state history for molecule 1
history = state_history[1]
frames = [h[1] for h in history]
states = [h[2] for h in history]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/analysis.jl#L145-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.InteractionDiffusion.update_system-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, DiffusionSMLMParams, Float64}" href="#SMLMSim.InteractionDiffusion.update_system-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, DiffusionSMLMParams, Float64}"><code>SMLMSim.InteractionDiffusion.update_system</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_system(emitters::Vector{&lt;:AbstractDiffusingEmitter}, params::DiffusionSMLMParams, dt::Float64)</code></pre><p>Update all emitters based on Smoluchowski diffusion dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Current emitters state</li><li><code>params::DiffusionSMLMParams</code>: Simulation parameters</li><li><code>dt::Float64</code>: Time step</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Updated emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.simulate-Tuple{DiffusionSMLMParams}" href="#SMLMSim.simulate-Tuple{DiffusionSMLMParams}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(params::DiffusionSMLMParams; 
         starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractDiffusingEmitter}}=nothing,
         photons::Float64=1000.0, 
         override_count::Union{Nothing, Int}=nothing,
         kwargs...)</code></pre><p>Run a Smoluchowski diffusion simulation and return a BasicSMLD object with emitters that have both frame number and timestamp information.</p><p><strong>Arguments</strong></p><ul><li><code>params::DiffusionSMLMParams</code>: Simulation parameters</li><li><code>starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractDiffusingEmitter}}</code>: Optional starting emitters</li><li><code>photons::Float64=1000.0</code>: Number of photons per emitter</li><li><code>override_count::Union{Nothing, Int}=nothing</code>: Optional override for the number of molecules</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>Any additional parameters are ignored (allows unified interface with other simulate methods)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: Single SMLD object containing all emitters across all frames</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Set up parameters with camera settings
params = DiffusionSMLMParams(
    density = 0.5,           # molecules per μm²
    box_size = 10.0,         # μm
    camera_framerate = 20.0, # 20 fps
    camera_exposure = 0.04   # 40ms exposure
)

# Run basic simulation
smld = simulate(params)

# Run simulation with exactly 2 particles
smld = simulate(params; override_count=2)

# Use previous simulation state as starting conditions for a new simulation
final_frame = maximum([e.frame for e in smld.emitters])
final_state_emitters = filter(e -&gt; e.frame == final_frame, smld.emitters)
smld_continued = simulate(params; starting_conditions=final_state_emitters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/diffusion/smoluchowski.jl#L340-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.CameraImages" href="#SMLMSim.CameraImages"><code>SMLMSim.CameraImages</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CameraImages</code></pre><p>Module for generating simulated camera images from SMLM data.</p><p>This module provides functions to:</p><ol><li>Generate ideal camera images by integrating emitter photons over a PSF.</li><li>Add realistic camera noise (e.g., Poisson noise).</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.CameraImages</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/camera_images/CameraImages.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.CameraImages.gen_image-Tuple{SMLMData.SMLD, AbstractPSF, Int64}" href="#SMLMSim.CameraImages.gen_image-Tuple{SMLMData.SMLD, AbstractPSF, Int64}"><code>SMLMSim.CameraImages.gen_image</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_image(smld::SMLD, psf::AbstractPSF, frame::Int; kwargs...) -&gt; Matrix{T} where T&lt;:Real</code></pre><p>Generate a single camera image for a specific frame from SMLD data. See <code>gen_images</code> for full documentation of parameters.</p><p><strong>Returns</strong></p><ul><li>A 2D camera image as Matrix{T} where T matches the type of emitter.photons</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/camera_images/gen_images.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.CameraImages.gen_images-Tuple{SMLMData.SMLD, AbstractPSF}" href="#SMLMSim.CameraImages.gen_images-Tuple{SMLMData.SMLD, AbstractPSF}"><code>SMLMSim.CameraImages.gen_images</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_images(smld::SMLD, psf::AbstractPSF; kwargs...) -&gt; Array{T, 3} where T&lt;:Real</code></pre><p>Generate camera images from SMLD data using the specified PSF model.</p><p><strong>Arguments</strong></p><ul><li><code>smld::SMLD</code>: Single molecule localization data container</li><li><code>psf::AbstractPSF</code>: Point spread function model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>dataset::Int=1</code>: Dataset number to use from SMLD</li><li><code>frames=nothing</code>: Specific frames to generate (default: all frames in smld.n_frames)</li><li><code>support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}}=Inf</code>: PSF support region size</li><li><code>sampling::Int=2</code>: Supersampling factor for PSF integration</li><li><code>threaded::Bool=true</code>: Enable multithreading for faster computation</li><li><code>bg::Float64=0.0</code>: Background signal level (photons per pixel)</li><li><code>poisson_noise::Bool=false</code>: Apply Poisson noise</li><li><code>camera_noise::Bool=false</code>: Apply camera read noise (Note: This feature is not yet implemented)</li></ul><p><strong>Returns</strong></p><ul><li>3D array of camera images with dimensions [height, width, num_frames]</li><li>The element type T matches the type of emitter.photons (typically Float64)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/camera_images/gen_images.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.CameraImages.poisson_noise!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real" href="#SMLMSim.CameraImages.poisson_noise!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>SMLMSim.CameraImages.poisson_noise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poisson_noise!(image::AbstractArray{T}) where T&lt;:Real -&gt; nothing</code></pre><p>Apply Poisson noise to an image or image stack in-place.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractArray{T}</code>: Input image or image stack with values representing photon counts</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The input array is modified in-place</li></ul><p><strong>Details</strong></p><p>Same as <code>poisson_noise</code>, but modifies the input array directly instead of creating a new one. This can be more memory-efficient for large images or when processing multiple frames.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Add Poisson noise to an image in-place
image = ones(100, 100) * 100.0  # 100 expected photons per pixel
poisson_noise!(image)  # image is modified in-place</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/camera_images/noise.jl#L42-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SMLMSim.CameraImages.poisson_noise-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real" href="#SMLMSim.CameraImages.poisson_noise-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>SMLMSim.CameraImages.poisson_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poisson_noise(image::AbstractArray{T}) where T&lt;:Real -&gt; Array{Float64}</code></pre><p>Apply Poisson noise to an image or image stack.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractArray{T}</code>: Input image or image stack with values representing photon counts</li></ul><p><strong>Returns</strong></p><ul><li>Array with same dimensions as input, with Poisson noise applied to each pixel</li></ul><p><strong>Details</strong></p><p>This function creates a copy of the input array and applies Poisson noise  to each pixel using the in-place poisson_noise! function.</p><p>Non-integer and negative values are handled specially:</p><ul><li>Non-integer values are accepted (treating them as expected photon counts)</li><li>Negative values are clipped to zero before applying noise</li><li>Zero values remain zero (as Poisson(0) always returns 0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Add Poisson noise to a clean image
clean_image = ones(100, 100) * 100.0  # 100 expected photons per pixel
noisy_image = poisson_noise(clean_image)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/cd7256041265ee329ef0074a3ec9e89624d6b96b/src/camera_images/noise.jl#L4-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../images/">« Microscope Images</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 22:27">Monday 28 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
