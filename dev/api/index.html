<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SMLMSim.jl</title><meta name="title" content="API Reference · SMLMSim.jl"/><meta property="og:title" content="API Reference · SMLMSim.jl"/><meta property="twitter:title" content="API Reference · SMLMSim.jl"/><meta name="description" content="Documentation for SMLMSim.jl."/><meta property="og:description" content="Documentation for SMLMSim.jl."/><meta property="twitter:description" content="Documentation for SMLMSim.jl."/><meta property="og:url" content="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><meta property="twitter:url" content="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><link rel="canonical" href="https://JuliaSMLM.github.io/SMLMSim.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SMLMSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Core Components</span><ul><li><a class="tocitem" href="../core/patterns/">Patterns</a></li><li><a class="tocitem" href="../core/labeling/">Labeling</a></li><li><a class="tocitem" href="../core/photophysics/">Photophysics</a></li><li><a class="tocitem" href="../core/noise/">Localization Uncertainty</a></li></ul></li><li><span class="tocitem">Static SMLM</span><ul><li><a class="tocitem" href="../static/overview/">Overview</a></li><li><a class="tocitem" href="../static/examples/">Examples</a></li></ul></li><li><span class="tocitem">Diffusion-Interaction</span><ul><li><a class="tocitem" href="../diffusion/overview/">Overview</a></li><li><a class="tocitem" href="../diffusion/examples/">Examples</a></li></ul></li><li><a class="tocitem" href="../images/">Microscope Images</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides a comprehensive reference for the types and functions in SMLMSim.</p><article><details class="docstring" open="true"><summary id="SMLMSim.SMLMSim"><a class="docstring-binding" href="#SMLMSim.SMLMSim"><code>SMLMSim.SMLMSim</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">SMLMSim</code></pre><p>Main module for the SMLMSim.jl package.</p><p><strong>API Overview</strong></p><p>For a comprehensive overview of the API, use the help mode on <code>api</code>:</p><pre><code class="language-julia hljs">?api</code></pre><p>Or access the complete API documentation programmatically:</p><pre><code class="language-julia hljs">docs = SMLMSim.api()</code></pre><p>This package provides tools for simulating Single Molecule Localization Microscopy (SMLM) data. It includes modules for:</p><ul><li><strong>Core:</strong> Fundamental types (molecules, patterns) and photophysics simulation (CTMC, blinking).</li><li><strong>StaticSMLM:</strong> Simulating static emitters with blinking and localization noise.</li><li><strong>InteractionDiffusion:</strong> Simulating diffusing and interacting emitters (e.g., dimerization) using Smoluchowski dynamics.</li><li><strong>CameraImages:</strong> Generating simulated camera images from emitter data, including noise models.</li></ul><p>The main <code>SMLMSim</code> module re-exports key types and functions from these submodules to provide a unified user interface.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim

# Example: Static simulation
params_static = StaticSMLMConfig(density=1.0, σ_psf=0.13)
smld_noisy, info = simulate(params_static)
# Access intermediate results: info.smld_true, info.smld_model

# Example: Diffusion simulation
params_diff = DiffusionSMLMConfig(density=0.5, diff_monomer=0.1)
smld, info = simulate(params_diff)

# Example: Generate images
psf = GaussianPSF(0.15)
images, img_info = gen_images(smld_noisy, psf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/SMLMSim.jl#L1-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.ImageInfo"><a class="docstring-binding" href="#SMLMSim.ImageInfo"><code>SMLMSim.ImageInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ImageInfo</code></pre><p>Metadata from image generation functions.</p><p><strong>Fields</strong></p><ul><li><code>elapsed_s::Float64</code>: Wall-clock time for image generation in seconds</li><li><code>backend::Symbol</code>: Computation backend (<code>:cpu</code>)</li><li><code>device_id::Int</code>: Device identifier (-1 for CPU)</li><li><code>frames_generated::Int</code>: Number of frames generated</li><li><code>n_photons_total::Float64</code>: Total photon count across all frames</li><li><code>output_size::Tuple{Int,Int,Int}</code>: Image dimensions (height, width, n_frames)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">images, info = gen_images(smld, psf)
println(&quot;Generated $(info.frames_generated) frames in $(info.elapsed_s) seconds&quot;)
println(&quot;Total photons: $(info.n_photons_total)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/types.jl#L74-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.SimInfo"><a class="docstring-binding" href="#SMLMSim.SimInfo"><code>SMLMSim.SimInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimInfo</code></pre><p>Metadata and intermediate results from simulation functions.</p><p><strong>Fields</strong></p><ul><li><code>elapsed_s::Float64</code>: Wall-clock time for simulation in seconds</li><li><code>backend::Symbol</code>: Computation backend (<code>:cpu</code>)</li><li><code>device_id::Int</code>: Device identifier (-1 for CPU)</li><li><code>seed::Union{UInt64, Nothing}</code>: RNG seed for reproducibility (if applicable)</li><li><code>smld_true::Union{BasicSMLD, Nothing}</code>: Ground truth positions (static simulation only)</li><li><code>smld_model::Union{BasicSMLD, Nothing}</code>: After kinetic model (static simulation only)</li><li><code>n_patterns::Int</code>: Number of spatial patterns generated</li><li><code>n_emitters::Int</code>: Total emitters simulated</li><li><code>n_localizations::Int</code>: Total localizations generated</li><li><code>n_frames::Int</code>: Number of frames in simulation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">smld_noisy, info = simulate(params)
println(&quot;Simulation took $(info.elapsed_s) seconds&quot;)
println(&quot;Generated $(info.n_localizations) localizations from $(info.n_emitters) emitters&quot;)

# Access intermediate results for analysis
if info.smld_true !== nothing
    # Compare true vs noisy positions
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/types.jl#L8-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.api-Tuple{}"><a class="docstring-binding" href="#SMLMSim.api-Tuple{}"><code>SMLMSim.api</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>SMLMSim.jl API Overview</strong></p><p>SMLMSim is a Julia package for simulating Single Molecule Localization Microscopy (SMLM) data with realistic physical properties. It provides tools for generating static SMLM simulations, diffusion-interaction simulations, and microscope image generation.</p><p><strong>Key Concepts</strong></p><p><strong>Physical Units</strong></p><p>All simulations use consistent physical units:</p><ul><li>Spatial dimensions: microns (μm)</li><li>Time: seconds (s)</li><li>Diffusion coefficients: μm²/s</li><li>Rate constants: s⁻¹</li></ul><p><strong>Core Components</strong></p><ul><li><strong>Patterns</strong>: Spatial arrangements of molecules (e.g., oligomers, lines)</li><li><strong>Molecules</strong>: Photophysical models of fluorophores with state transitions</li><li><strong>Simulation</strong>: Parameters and functions for different simulation types</li><li><strong>Noise</strong>: Realistic localization uncertainty based on photon statistics</li><li><strong>Camera Images</strong>: Generation of microscope images from simulation data</li></ul><p><strong>Type Hierarchy</strong></p><ul><li><p><code>AbstractSMLMConfig</code>: Base type for all config types (from SMLMData)</p><ul><li><code>SMLMSimParams</code>: Base type for simulation parameters<ul><li><code>StaticSMLMConfig</code>: Parameters for static SMLM simulation</li><li><code>DiffusionSMLMConfig</code>: Parameters for diffusion simulation</li></ul></li></ul></li><li><p><code>AbstractSMLMInfo</code>: Base type for info structs (from SMLMData)</p><ul><li><code>SimInfo</code>: Metadata and intermediate results from simulation functions</li><li><code>ImageInfo</code>: Metadata from image generation functions</li></ul></li><li><p><code>Pattern</code>: Base type for all molecular patterns</p><ul><li><code>Pattern2D</code>: Base type for 2D patterns<ul><li><code>Nmer2D</code>: N molecules arranged in a circle</li><li><code>Line2D</code>: Molecules arranged along a line</li></ul></li><li><code>Pattern3D</code>: Base type for 3D patterns<ul><li><code>Nmer3D</code>: N molecules arranged in a circle in 3D</li><li><code>Line3D</code>: Molecules arranged along a 3D line</li></ul></li></ul></li><li><p><code>AbstractLabeling</code>: Base type for labeling strategies</p><ul><li><code>FixedLabeling</code>: Deterministic number of fluorophores per site</li><li><code>PoissonLabeling</code>: Poisson-distributed number of fluorophores per site</li><li><code>BinomialLabeling</code>: Binomial-distributed number of fluorophores per site</li></ul></li><li><p><code>Molecule</code>: Base type for all photophysical models</p><ul><li><code>GenericFluor</code>: General fluorophore with kinetic state model</li></ul></li><li><p><code>AbstractDiffusingEmitter</code>: Base type for diffusing emitters</p><ul><li><code>DiffusingEmitter2D</code>: 2D emitter with diffusion state</li><li><code>DiffusingEmitter3D</code>: 3D emitter with diffusion state</li></ul></li></ul><p><strong>Essential Types</strong></p><p><strong>StaticSMLMConfig</strong></p><p>Parameters for static SMLM simulation with fixed molecular patterns.</p><pre><code class="language-julia hljs">Base.@kwdef mutable struct StaticSMLMConfig &lt;: SMLMSimParams
    density::Float64 = 1.0          # density in particles per square micron
    σ_psf::Float64 = 0.13           # PSF width in microns
    minphotons::Int = 50            # minimum photons for detection
    ndatasets::Int = 10             # number of datasets to simulate
    nframes::Int = 1000             # number of frames per dataset
    framerate::Float64 = 50.0       # frames per second
    ndims::Int = 2                  # dimensionality (2 or 3)
    zrange::Vector{Float64} = [-1.0, 1.0]  # axial range for 3D simulations [min_z, max_z]
end</code></pre><p><strong>DiffusionSMLMConfig</strong></p><p>Parameters for diffusion-based SMLM simulation using Smoluchowski dynamics.</p><pre><code class="language-julia hljs">Base.@kwdef mutable struct DiffusionSMLMConfig &lt;: SMLMSimParams
    density::Float64 = 1.0          # number density (molecules/μm²)
    box_size::Float64 = 10.0        # simulation box size (μm)
    diff_monomer::Float64 = 0.1     # monomer diffusion coefficient (μm²/s)
    diff_dimer::Float64 = 0.05      # dimer diffusion coefficient (μm²/s)
    diff_dimer_rot::Float64 = 0.5   # dimer rotational diffusion coefficient (rad²/s)
    k_off::Float64 = 0.2            # dimer dissociation rate (s⁻¹)
    r_react::Float64 = 0.01         # reaction radius (μm)
    d_dimer::Float64 = 0.05         # monomer separation in dimer (μm)
    dt::Float64 = 0.01              # time step (s)
    t_max::Float64 = 10.0           # total simulation time (s)
    ndims::Int = 2                  # number of dimensions (2 or 3)
    boundary::String = &quot;periodic&quot;   # boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)
    camera_framerate::Float64 = 10.0 # camera frames per second (Hz)
    camera_exposure::Float64 = 0.1   # camera exposure time per frame (s)
end</code></pre><p><strong>Molecular Patterns</strong></p><p><strong>Nmer2D</strong></p><p>N molecules symmetrically organized around a circle with diameter d.</p><pre><code class="language-julia hljs">mutable struct Nmer2D &lt;: Pattern2D
    n::Int               # Number of molecules in the pattern
    d::Float64           # Diameter of the circle in microns
    x::Vector{Float64}   # X positions of molecules in microns
    y::Vector{Float64}   # Y positions of molecules in microns
end</code></pre><p><strong>Line2D</strong></p><p>Points with uniform random distribution between two endpoints.</p><pre><code class="language-julia hljs">mutable struct Line2D &lt;: Pattern2D
    n::Int                # Number of molecules in the pattern
    x::Vector{Float64}    # X positions of molecules in microns
    y::Vector{Float64}    # Y positions of molecules in microns
    λ::Float64            # Linear molecule density (molecules per micron)
    endpoints::Vector{Tuple{Float64,Float64}}  # Vector of endpoint coordinates
end</code></pre><p><strong>Info Types</strong></p><p><strong>SimInfo</strong></p><p>Metadata and intermediate results from simulation functions. Returned as the second element of the tuple from <code>simulate()</code>.</p><pre><code class="language-julia hljs">struct SimInfo &lt;: AbstractSMLMInfo
    elapsed_s::Float64              # Wall-clock time in seconds
    backend::Symbol                 # Computation backend (:cpu)
    device_id::Int                  # Device identifier (-1 for CPU)
    seed::Union{UInt64, Nothing}    # RNG seed for reproducibility
    smld_true::Any                  # Ground truth positions (static only)
    smld_model::Any                 # After kinetic model (static only)
    n_patterns::Int                 # Number of spatial patterns
    n_emitters::Int                 # Total emitters simulated
    n_localizations::Int            # Total localizations generated
    n_frames::Int                   # Number of frames
end</code></pre><p><strong>ImageInfo</strong></p><p>Metadata from image generation functions. Returned as the second element of the tuple from <code>gen_images()</code> and <code>gen_image()</code>.</p><pre><code class="language-julia hljs">struct ImageInfo &lt;: AbstractSMLMInfo
    elapsed_s::Float64              # Wall-clock time in seconds
    backend::Symbol                 # Computation backend (:cpu)
    device_id::Int                  # Device identifier (-1 for CPU)
    frames_generated::Int           # Number of frames generated
    n_photons_total::Float64        # Total photon count
    output_size::Tuple{Int,Int,Int} # Image dimensions (H, W, T)
end</code></pre><p><strong>Fluorophore Models</strong></p><p><strong>GenericFluor</strong></p><p>Defines a fluorophore with photophysical properties.</p><pre><code class="language-julia hljs">struct GenericFluor &lt;: Molecule
    γ::AbstractFloat     # Photon emission rate in Hz
    q::Array{&lt;:AbstractFloat}  # Rate matrix for state transitions
end</code></pre><p><strong>Labeling Strategies</strong></p><p>Labeling is separate from photophysics (Molecule). These types control how many fluorophores attach to each binding site, while Molecule handles blinking kinetics of each fluorophore.</p><p><strong>AbstractLabeling</strong></p><p>Abstract type for labeling strategies. All implementations support an <code>efficiency</code> parameter controlling the probability that a binding site gets labeled at all.</p><p><strong>FixedLabeling</strong></p><p>Deterministic labeling with exactly <code>n</code> fluorophores per site.</p><pre><code class="language-julia hljs">struct FixedLabeling &lt;: AbstractLabeling
    n::Int               # Number of fluorophores per site
    efficiency::Float64  # Probability that a site gets labeled (0 to 1)
end</code></pre><p><strong>PoissonLabeling</strong></p><p>Poisson-distributed number of fluorophores per site.</p><pre><code class="language-julia hljs">struct PoissonLabeling &lt;: AbstractLabeling
    mean::Float64        # Mean number of fluorophores per site (λ for Poisson)
    efficiency::Float64  # Probability that a site gets labeled (0 to 1)
end</code></pre><p>Note: With Poisson statistics, some sites may receive 0 fluorophores even when efficiency=1.0 (especially for small mean values).</p><p><strong>BinomialLabeling</strong></p><p>Binomial-distributed number of fluorophores per site. Models scenarios where each binding site has <code>n</code> potential attachment points, each occupied with probability <code>p</code>.</p><pre><code class="language-julia hljs">struct BinomialLabeling &lt;: AbstractLabeling
    n::Int               # Number of potential attachment points per site
    p::Float64           # Probability each attachment point is occupied (0 to 1)
    efficiency::Float64  # Probability that a site gets labeled (0 to 1)
end</code></pre><p><strong>Constructor Examples</strong></p><p><strong>Creating Simulation Parameters</strong></p><pre><code class="language-julia hljs"># Static SMLM with default parameters
params_static = StaticSMLMConfig()

# Custom parameters for static simulation
params_static = StaticSMLMConfig(
    density = 2.0,        # 2 patterns per μm²
    σ_psf = 0.15,         # 150nm PSF width
    nframes = 2000,       # 2000 frames
    framerate = 20.0      # 20 fps
)

# Diffusion simulation with default parameters
params_diff = DiffusionSMLMConfig()

# Custom parameters for diffusion simulation
params_diff = DiffusionSMLMConfig(
    density = 0.5,        # molecules per μm²
    box_size = 15.0,      # 15μm box size
    diff_monomer = 0.2,   # 0.2 μm²/s diffusion coefficient
    k_off = 0.1,          # 0.1 s⁻¹ dissociation rate
    t_max = 20.0          # 20s simulation time
)</code></pre><p><strong>Creating Patterns</strong></p><pre><code class="language-julia hljs"># Create an 8-molecule pattern with 100nm diameter (default)
nmer = Nmer2D()

# Create a custom pattern with 6 molecules and 200nm diameter
hexamer = Nmer2D(n=6, d=0.2)  # d is in microns

# Create a 3D pattern
octamer3d = Nmer3D(n=8, d=0.15)

# Create a line pattern
line = Line2D(λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])  # 5 molecules/μm

# Create a 3D line pattern
line3d = Line3D(λ=8.0, endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)])</code></pre><p><strong>Creating Fluorophore Models</strong></p><pre><code class="language-julia hljs"># Create a fluorophore with default parameters
fluor = GenericFluor()

# Create a fluorophore with custom parameters
# γ=100,000 photons/s, k_off=10 Hz, k_on=0.1 Hz
fluor = GenericFluor(1e5, [-10.0 10.0; 0.1 -0.1])

# Create a fluorophore using the 2-state keyword constructor
fluor = GenericFluor(photons=1e5, k_off=50.0, k_on=1e-2)</code></pre><p><strong>Creating Labeling Strategies</strong></p><pre><code class="language-julia hljs"># Perfect labeling - exactly 1 fluorophore per site (default)
labeling = FixedLabeling()

# 2 fluorophores per site, 90% of sites labeled
labeling = FixedLabeling(2; efficiency=0.9)

# Poisson labeling - average 1.5 fluorophores per site
labeling = PoissonLabeling(1.5)

# Poisson with 80% labeling efficiency
labeling = PoissonLabeling(2.0; efficiency=0.8)

# Binomial labeling - antibody with 4 dye attachment points, 80% occupancy
labeling = BinomialLabeling(4, 0.8)

# Same with 90% of sites receiving an antibody
labeling = BinomialLabeling(4, 0.8; efficiency=0.9)</code></pre><p><strong>Creating a Camera</strong></p><pre><code class="language-julia hljs"># IdealCamera: Poisson noise only
camera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels

# Specify field of view with an array of pixel edges
pixel_edges_x = 0.0:0.1:12.8  # 0 to 12.8μm in 0.1μm steps
pixel_edges_y = 0.0:0.1:12.8
camera = IdealCamera(pixel_edges_x, pixel_edges_y)

# SCMOSCamera: Realistic noise model with per-pixel calibration (SMLMData 0.4+)
# Parameters: width, height, pixel_size, readnoise
camera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)  # 1.6 e⁻ RMS read noise

# Advanced: Specify all calibration parameters
# offset (ADU), gain (e⁻/ADU), readnoise (e⁻ RMS), quantum efficiency (0-1)
camera_scmos = SCMOSCamera(
    128, 128, 0.1;
    offset=100.0,      # 100 ADU dark level
    gain=0.5,          # 0.5 e⁻/ADU
    readnoise=1.6,     # 1.6 e⁻ RMS
    qe=0.95            # 95% quantum efficiency
)</code></pre><p><strong>Core Functions</strong></p><p><strong>Simulation</strong></p><p><strong>simulate</strong></p><p>The main simulation function with multiple methods for different simulation types. All <code>simulate()</code> methods return a tuple: <code>(primary_output, info)</code>.</p><pre><code class="language-julia hljs"># Static SMLM simulation
# First create simulation parameters
params = StaticSMLMConfig()

# Then run simulation - returns (smld_noisy, SimInfo)
smld_noisy, info = simulate(
    params;
    pattern=Nmer2D(),
    labeling=FixedLabeling(),      # Default: 1 fluorophore per site
    molecule=GenericFluor(),
    camera=IdealCamera(128, 128, 0.1)
)

# Access intermediate results from info
smld_true = info.smld_true    # Ground truth positions
smld_model = info.smld_model  # After kinetic model

# With Poisson labeling (variable fluorophores per site)
smld_noisy, info = simulate(
    params;
    pattern=Nmer2D(n=6, d=0.2),
    labeling=PoissonLabeling(1.5),  # Average 1.5 fluorophores per site
    molecule=GenericFluor()
)

# Diffusion simulation
# First create simulation parameters
params_diff = DiffusionSMLMConfig()

# Then run simulation - returns (smld, SimInfo)
smld, info = simulate(
    params_diff;
    photons=1000.0
)

# Check timing
println(&quot;Simulation took $(info.elapsed_s) seconds&quot;)</code></pre><p><strong>kinetic_model</strong></p><p>Generate kinetic blinking model from existing localization data.</p><pre><code class="language-julia hljs"># Example of how to call kinetic_model
# First create or obtain the required inputs
smld_true = ... # Some BasicSMLD with true positions
fluor = GenericFluor(1e5, [-10.0 10.0; 0.5 -0.5])  # Fluorophore model
nframes = 1000    # Number of frames
framerate = 50.0  # Frames per second

# Call the function
smld_model = kinetic_model(
    smld_true,     # BasicSMLD with emitter positions
    fluor,         # Molecule with kinetic rates
    nframes,       # Number of frames
    framerate;     # Frames per second
    ndatasets=1,   # Number of independent datasets
    minphotons=50.0, # Minimum photons for detection
    state1=:equilibrium  # Initial state sampling
)</code></pre><p><strong>apply_noise</strong></p><p>Add localization uncertainty to emitter positions based on photon counts.</p><pre><code class="language-julia hljs"># Example usage of apply_noise

# First, you need smld_model from a previous step
# For example, from the output of kinetic_model()

# For 2D emitters - add noise with 130nm PSF width
smld_noisy = apply_noise(smld_model, 0.13)  # 0.13 μm = 130nm PSF width

# For 3D emitters - specify PSF width in each dimension
smld_noisy_3d = apply_noise(smld_model_3d, [0.13, 0.13, 0.39])  # [x, y, z] widths in μm</code></pre><p><strong>Image Generation</strong></p><p><strong>gen_images</strong></p><p>Generate camera images from SMLD data using the specified PSF model. Returns a tuple: <code>(images, ImageInfo)</code>.</p><pre><code class="language-julia hljs">images, info = gen_images(
    smld::SMLD,
    psf::AbstractPSF;
    dataset::Int=1,                # Dataset number to use from SMLD
    frames=nothing,                # Specific frames to generate (default: all frames)
    support=Inf,                   # PSF support region size (see details below)
    sampling=2,                    # Supersampling factor for PSF integration
    threaded=true,                 # Enable multithreading
    bg=0.0,                        # Background signal level (photons per pixel)
    poisson_noise=false,           # Apply Poisson noise only (simple shot noise)
    camera_noise=false             # Apply full camera noise model (requires SCMOSCamera)
                                   # - For SCMOSCamera: QE, Poisson, read noise, gain, offset
                                   # - For IdealCamera: ignored (use poisson_noise instead)
)

# Access image metadata
println(&quot;Generated $(info.frames_generated) frames in $(info.elapsed_s) seconds&quot;)
println(&quot;Total photons: $(info.n_photons_total)&quot;)

# The support parameter controls PSF computation region:
# 1. Inf (default): Compute PSF over entire image (most accurate but slowest)
support=Inf

# 2. Real number: Use circular region with given radius around each emitter
# Typically 3-5× the PSF width is sufficient for accuracy with better performance
support=1.0  # 1.0 µm radius around each emitter

# 3. Tuple (xmin, xmax, ymin, ymax): Explicit region in microns
support=(4.0, 6.0, 4.0, 6.0)  # Only compute PSF within this region

# Example: sCMOS camera with realistic noise
camera_scmos = SCMOSCamera(128, 128, 0.1, 1.6)
smld = BasicSMLD(emitters, camera_scmos, n_frames, n_datasets)
images_scmos, info = gen_images(smld, psf, bg=10.0, camera_noise=true)
# Applies: QE → Poisson → read noise → gain → offset

# Example: IdealCamera with Poisson noise only
camera_ideal = IdealCamera(128, 128, 0.1)
smld = BasicSMLD(emitters, camera_ideal, n_frames, n_datasets)
images_poisson, info = gen_images(smld, psf, bg=10.0, poisson_noise=true)</code></pre><p><strong>gen_image</strong></p><p>Generate a single frame camera image. Returns a tuple: <code>(image, ImageInfo)</code>.</p><pre><code class="language-julia hljs"># Example of generating a single frame image

# First, define variables
smld = ... # Your SMLD data
psf = GaussianPSF(0.15)  # PSF model with 150nm width
frame_number = 10  # The frame you want to generate

# Generate image for a specific frame
single_frame, info = gen_image(
    smld,          # SMLD data
    psf,           # PSF model
    frame_number;  # Frame to generate
    support=1.0,   # Same keyword arguments as gen_images
    bg=5.0,
    poisson_noise=true
)</code></pre><p><strong>Analysis Functions</strong></p><p><strong>Diffusion Analysis</strong></p><pre><code class="language-julia hljs"># Example usage of diffusion analysis functions

# First, run a diffusion simulation
params = DiffusionSMLMConfig()
smld, info = simulate(params)

# Extract dimers from diffusion simulation
dimer_smld = get_dimers(smld)

# Extract monomers
monomer_smld = get_monomers(smld)

# Analyze dimer formation over time
frames, fractions = analyze_dimer_fraction(smld)

# Analyze average dimer lifetime
lifetime = analyze_dimer_lifetime(smld)

# Track state changes over time
state_history = track_state_changes(smld)</code></pre><p><strong>Track Utilities</strong></p><pre><code class="language-julia hljs"># Example usage of track utilities

# First, run a simulation
params = StaticSMLMConfig()
smld_noisy, info = simulate(params)

# Specify a track ID to extract
track_id = 1  # ID of the track to extract

# Get a specific track by ID
track_smld = get_track(smld_noisy, track_id)

# Get number of unique tracks
n_tracks = get_num_tracks(smld_noisy)

# Get all tracks as separate SMLDs
track_smlds = get_tracks(smld_noisy)</code></pre><p><strong>Pattern Manipulation</strong></p><pre><code class="language-julia hljs"># Example usage of pattern manipulation

# Create patterns
pattern2d = Nmer2D(n=6, d=0.2)
pattern3d = Nmer3D(n=8, d=0.15)

# Rotate a 2D pattern by 45 degrees
rotate!(pattern2d, π/4)

# Rotate a 3D pattern with Euler angles (ZYZ convention)
rotate!(pattern3d, π/4, π/6, π/3)  # α, β, γ angles

# Rotate a 3D pattern with a rotation matrix
θ = π/2 # 90 degrees
R = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]  # Z-axis rotation
rotate!(pattern3d, R)</code></pre><p><strong>Labeling Functions</strong></p><p><strong>apply_labeling</strong></p><p>Apply labeling strategy to binding site coordinates, expanding each site to the appropriate number of fluorophore positions while preserving pattern IDs.</p><pre><code class="language-julia hljs"># Generate binding site coordinates with pattern IDs from pattern distribution
x, y, pattern_ids = uniform2D(1.0, Nmer2D(), 10.0, 10.0)

# Apply labeling with pattern ID tracking (returns coords tuple and new IDs)
(x_labeled, y_labeled), new_ids = apply_labeling((x, y), pattern_ids, PoissonLabeling(1.5))

# Backward-compatible: without pattern IDs (returns only coords)
x_labeled, y_labeled = apply_labeling((x, y), FixedLabeling(1; efficiency=0.8))

# Works with 3D coordinates too
x, y, z, pattern_ids = uniform3D(1.0, Nmer3D(), 10.0, 10.0)
(x_labeled, y_labeled, z_labeled), new_ids = apply_labeling((x, y, z), pattern_ids, BinomialLabeling(4, 0.8))</code></pre><p><strong>n_fluorophores</strong></p><p>Sample the number of fluorophores to place at a single binding site. Called internally by <code>apply_labeling</code>, but can be used directly for custom workflows.</p><pre><code class="language-julia hljs">labeling = PoissonLabeling(1.5)

# Sample number of fluorophores for one site
n = n_fluorophores(labeling)  # Returns Int (can be 0)</code></pre><p><strong>Pattern Distribution</strong></p><p>Generate random pattern distributions in a field. Each function returns coordinates plus pattern instance IDs for tracking which emitters belong to the same pattern.</p><pre><code class="language-julia hljs"># Create patterns
pattern2d = Nmer2D(n=6, d=0.2)
pattern3d = Nmer3D(n=8, d=0.15)

# Generate random pattern distribution in a field
field_x = 10.0 # μm
field_y = 10.0 # μm
density = 1.0  # patterns per μm²

# Get coordinates for 2D distribution (returns pattern IDs)
x, y, pattern_ids = uniform2D(density, pattern2d, field_x, field_y)
# pattern_ids[i] indicates which pattern instance point i belongs to

# Get coordinates for 3D distribution (returns pattern IDs)
x, y, z, pattern_ids = uniform3D(density, pattern3d, field_x, field_y, zrange=[-2.0, 2.0])</code></pre><p><strong>Common Workflows</strong></p><p><strong>Static SMLM Simulation Workflow</strong></p><ol><li>Define simulation parameters</li><li>Create a pattern (or use default)</li><li>Choose a labeling strategy (or use default FixedLabeling)</li><li>Define a fluorophore model (or use default)</li><li>Run simulation to get noisy localizations and info (with intermediate results)</li><li>Generate microscope images or analyze the data</li></ol><pre><code class="language-julia hljs"># 1. Define parameters
params = StaticSMLMConfig(
    density = 1.0,
    σ_psf = 0.13,
    nframes = 1000
)

# 2. Create a pattern
pattern = Nmer2D(n=6, d=0.2)  # hexamer with 200nm diameter

# 3. Choose labeling strategy
labeling = PoissonLabeling(1.5)  # Average 1.5 fluorophores per binding site

# 4. Define fluorophore model
fluor = GenericFluor(photons=1e5, k_off=50.0, k_on=1e-2)

# 5. Run simulation - returns (smld_noisy, SimInfo)
smld_noisy, info = simulate(
    params;
    pattern=pattern,
    labeling=labeling,
    molecule=fluor
)

# Access intermediate results from info
smld_true = info.smld_true    # Ground truth positions
smld_model = info.smld_model  # After kinetic model

# 6. Create microscope images with efficient PSF support
psf = GaussianPSF(0.15)  # 150nm PSF width
images, img_info = gen_images(smld_model, psf;
    support=1.0,         # 1.0 μm radius around each emitter
    poisson_noise=true   # Add realistic photon counting noise
)</code></pre><p><strong>Diffusion Simulation Workflow</strong></p><ol><li>Define diffusion parameters</li><li>Run simulation to get emitter trajectories</li><li>Analyze the diffusion and interaction dynamics</li><li>Generate microscope images</li></ol><pre><code class="language-julia hljs"># 1. Define parameters
params = DiffusionSMLMConfig(
    density = 0.5,        # molecules per μm²
    box_size = 10.0,      # μm
    diff_monomer = 0.1,   # μm²/s
    diff_dimer = 0.05,    # μm²/s
    k_off = 0.2,          # s⁻¹
    t_max = 10.0          # s
)

# 2. Run simulation - returns (smld, SimInfo)
smld, info = simulate(params)

# 3. Analyze the results
dimer_smld = get_dimers(smld)
frames, fractions = analyze_dimer_fraction(smld)

# 4. Generate microscope images with realistic sCMOS noise
# Create sCMOS camera matching simulation box
n_pixels = Int(ceil(params.box_size / 0.1))  # 0.1 μm pixels
camera_scmos = SCMOSCamera(n_pixels, n_pixels, 0.1, 1.6)
smld_cam = BasicSMLD(smld.emitters, camera_scmos, smld.n_frames, 1)

psf = GaussianPSF(0.15)  # 150nm PSF width
images, img_info = gen_images(smld_cam, psf;
    support=1.0,         # 1.0 μm PSF support radius (faster)
    bg=5.0,              # Background photons per pixel
    camera_noise=true    # Full sCMOS noise model (QE, Poisson, read noise, gain, offset)
)</code></pre><p><strong>Complete Examples</strong></p><p><strong>Static SMLM with Image Generation</strong></p><pre><code class="language-julia hljs">using SMLMSim
using MicroscopePSFs

# Define a camera and simulation parameters
camera = IdealCamera(128, 128, 0.1)  # 128×128 pixels, 100nm pixels
params = StaticSMLMConfig(density=1.0, σ_psf=0.13, nframes=1000)

# Run simulation for an 8-molecule ring pattern
smld_noisy, info = simulate(
    params;
    pattern=Nmer2D(n=8, d=0.1),  # 100nm diameter ring
    molecule=GenericFluor(1e5, [-10.0 10.0; 0.5 -0.5]),  # γ=100,000, k_off=10, k_on=0.5
    camera=camera
)

# Access intermediate results from info
smld_model = info.smld_model

# Create a PSF model
psf = GaussianPSF(0.15)  # 150nm PSF width

# Generate microscope images with finite PSF support
images, img_info = gen_images(smld_model, psf;
    support=1.0,         # 1.0 μm PSF support radius (faster than Inf)
    bg=5.0,              # 5 background photons per pixel
    poisson_noise=true   # Add realistic photon counting noise
)

println(&quot;Generated $(length(smld_noisy.emitters)) localizations and $(img_info.frames_generated) images.&quot;)
println(&quot;Simulation took $(info.elapsed_s) seconds&quot;)</code></pre><p><strong>Diffusion with Dimer Analysis</strong></p><pre><code class="language-julia hljs">using SMLMSim
using MicroscopePSFs

# Set diffusion simulation parameters
params = DiffusionSMLMConfig(
    density = 0.5,        # molecules per μm²
    box_size = 10.0,      # μm
    diff_monomer = 0.1,   # μm²/s
    diff_dimer = 0.05,    # μm²/s
    k_off = 0.2,          # s⁻¹
    t_max = 10.0,         # s
    boundary = &quot;reflecting&quot;  # Use reflecting boundaries
)

# Run diffusion simulation
smld, info = simulate(params)

# Analyze dimer formation
frames, dimer_fraction = analyze_dimer_fraction(smld)
avg_lifetime = analyze_dimer_lifetime(smld)

# Generate microscope images with finite PSF support
psf = GaussianPSF(0.15)  # 150nm PSF width
images, img_info = gen_images(smld, psf;
    support=1.0,         # 1.0 μm PSF support radius (faster)
    bg=2.0,              # Background photons per pixel
    poisson_noise=true   # Add realistic photon counting noise
)

println(&quot;Simulation complete with $(length(smld.emitters)) emitters&quot;)
println(&quot;Average dimer fraction: $(mean(dimer_fraction))&quot;)
println(&quot;Average dimer lifetime: $(avg_lifetime) seconds&quot;)</code></pre><p><strong>Custom Pattern with 3D Simulation</strong></p><pre><code class="language-julia hljs">using SMLMSim
using MicroscopePSFs

# Define a custom 3D pattern: two rings at different z-positions
mutable struct DoubleRing3D &lt;: Pattern3D
    n::Int
    d1::Float64
    d2::Float64
    z1::Float64
    z2::Float64
    x::Vector{Float64}
    y::Vector{Float64}
    z::Vector{Float64}
end

function DoubleRing3D(; n=8, d1=0.1, d2=0.2, z1=-0.2, z2=0.2)
    total_n = 2*n
    x = zeros(total_n)
    y = zeros(total_n)
    z = zeros(total_n)

    # First ring (bottom)
    for i = 1:n
        θ = 2π * (i-1) / n
        x[i] = d1/2 * cos(θ)
        y[i] = d1/2 * sin(θ)
        z[i] = z1
    end

    # Second ring (top)
    for i = 1:n
        θ = 2π * (i-1) / n + π/n  # Offset angle for second ring
        x[n+i] = d2/2 * cos(θ)
        y[n+i] = d2/2 * sin(θ)
        z[n+i] = z2
    end

    return DoubleRing3D(n, d1, d2, z1, z2, x, y, z)
end

# Create camera and parameters
camera = IdealCamera(128, 128, 0.1)
params = StaticSMLMConfig(
    density = 0.5,
    σ_psf = 0.13,
    nframes = 2000,
    ndims = 3,
    zrange = [-1.0, 1.0]
)

# Create custom pattern
double_ring = DoubleRing3D(n=6, d1=0.15, d2=0.3, z1=-0.3, z2=0.3)

# Run simulation
smld_noisy, info = simulate(
    params;
    pattern=double_ring,
    camera=camera
)

# Access intermediate results
smld_model = info.smld_model

# Generate images with a 3D astigmatic PSF and finite support
# Create a PSF with astigmatism using Zernike coefficients
using MicroscopePSFs
zc = ZernikeCoefficients(15)
zc.phase[6] = 0.5  # Add vertical astigmatism
psf_scalar = ScalarPSF(1.4, 0.532, 1.52; zernike_coeffs=zc)

# Create SplinePSF for speed
xy_sampling, z_sampling = 0.05, 0.1
x_range = y_range = -1.0:xy_sampling:1.0
z_range = -1.0:z_sampling:1.0
psf_spline = SplinePSF(psf_scalar, x_range, y_range, z_range)

# Generate images using the spline PSF with finite support
images, img_info = gen_images(smld_model, psf_spline;
    support=0.5,         # 0.5 μm PSF support radius for performance
    bg=5.0,              # Background photons per pixel
    poisson_noise=true   # Add realistic photon counting noise
)

println(&quot;Generated $(length(smld_noisy.emitters)) localizations in 3D&quot;)</code></pre><hr/><p><code>api()</code> returns this documentation as a plain <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/api.jl#L26-L895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.simulate-Tuple{SMLMSimParams}"><a class="docstring-binding" href="#SMLMSim.simulate-Tuple{SMLMSimParams}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate(sim::SMLMSimParams; kwargs...)</code></pre><p>Generic interface for all simulation types. Dispatches to the appropriate method based on the concrete simulation type.</p><p><strong>Arguments</strong></p><ul><li><code>sim::SMLMSimParams</code>: The simulation configuration object</li><li><code>kwargs...</code>: Additional keyword arguments specific to the simulation type</li></ul><p><strong>Returns</strong></p><ul><li>The result of the specific simulation method</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a static SMLM simulation configuration
params = StaticSMLMConfig(
    density = 1.0,        # Changed from ρ to density
    σ_psf = 0.13
)

# Run the simulation
results = simulate(params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/interface.jl#L14-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core"><a class="docstring-binding" href="#SMLMSim.Core"><code>SMLMSim.Core</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">Core</code></pre><p>Core module with shared utilities for SMLM simulation.</p><p>This module contains fundamental components that can be used across different simulation types (static, diffusion, etc.) including:</p><ol><li>Abstract types for simulation</li><li>Molecule and pattern definitions</li><li>CTMC (Continuous Time Markov Chain) for stochastic state transitions</li><li>Photophysics modeling for blinking kinetics and detection</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.Core</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/Core.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.AbstractLabeling"><a class="docstring-binding" href="#SMLMSim.Core.AbstractLabeling"><code>SMLMSim.Core.AbstractLabeling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractLabeling</code></pre><p>Abstract type for labeling strategies that determine how many fluorophores attach to each binding site.</p><p>Labeling is separate from photophysics (Molecule) - this type hierarchy handles the statistics of fluorophore attachment, while Molecule handles blinking kinetics.</p><p><strong>Implementations</strong></p><ul><li><code>FixedLabeling</code>: Deterministic number of fluorophores per site</li><li><code>PoissonLabeling</code>: Poisson-distributed number of fluorophores per site</li><li><code>BinomialLabeling</code>: Binomial-distributed number of fluorophores per site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L2-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.BinomialLabeling"><a class="docstring-binding" href="#SMLMSim.Core.BinomialLabeling"><code>SMLMSim.Core.BinomialLabeling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BinomialLabeling &lt;: AbstractLabeling</code></pre><p>Binomial-distributed number of fluorophores per site. Models scenarios where each binding site has <code>n</code> potential attachment points, each occupied with probability <code>p</code>.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of potential attachment points per site</li><li><code>p::Float64</code>: Probability each attachment point is occupied (0 to 1)</li><li><code>efficiency::Float64</code>: Probability that a site gets labeled at all (0 to 1)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Antibody with 4 dye attachment points, each 80% likely to be occupied
labeling = BinomialLabeling(4, 0.8)

# Same, but only 90% of binding sites get an antibody
labeling = BinomialLabeling(4, 0.8; efficiency=0.9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L99-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.CTMC"><a class="docstring-binding" href="#SMLMSim.Core.CTMC"><code>SMLMSim.Core.CTMC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CTMC{T&lt;:AbstractFloat, U&lt;:Int}</code></pre><p>A Continuous Time Markov Chain representation storing the full trajectory of state transitions.</p><p><strong>Fields</strong></p><ul><li><code>simulation_time::T</code>: Total simulation time span</li><li><code>transition_times::Vector{T}</code>: Time points at which state changes occurred, starting at 0.0 </li><li><code>states::Vector{U}</code>: Sequence of states entered at each transition time, starting with initial state</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Floating point type for time values</li><li><code>U</code>: Integer type for state indices</li></ul><p><strong>Note</strong></p><p>The <code>states</code> and <code>transition_times</code> vectors have the same length, with each entry in <code>states[i]</code> representing the state entered at time <code>transition_times[i]</code>. The system remains in <code>states[i]</code>  until time <code>transition_times[i+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/ctmc.jl#L11-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.CTMC-Union{Tuple{T}, Tuple{Array{T}, T, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.CTMC-Union{Tuple{T}, Tuple{Array{T}, T, Int64}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.CTMC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMC(q::Array{T}, simulation_time::T, state1::Int) where {T&lt;:AbstractFloat}</code></pre><p>Construct a Continuous Time Markov Chain simulation from a rate matrix.</p><p><strong>Arguments</strong></p><ul><li><code>q::Array{T}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i</li><li><code>simulation_time::T</code>: Total time to simulate</li><li><code>state1::Int</code>: Initial state</li></ul><p><strong>Returns</strong></p><ul><li><code>CTMC{T,Int}</code>: Simulated CTMC with transition times and states</li></ul><p><strong>Details</strong></p><p>Simulates a CTMC using the Gillespie algorithm:</p><ol><li>Start in state1 at time 0</li><li>For current state i:<ul><li>Calculate total exit rate k<em>tot = Σ</em>j q[i,j]</li><li>Sample time until next transition from Exp(k_tot)</li><li>Sample next state j with probability q[i,j]/k_tot</li></ul></li><li>Repeat until exceeding simulation_time</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/ctmc.jl#L64-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.FixedLabeling"><a class="docstring-binding" href="#SMLMSim.Core.FixedLabeling"><code>SMLMSim.Core.FixedLabeling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FixedLabeling &lt;: AbstractLabeling</code></pre><p>Deterministic labeling with exactly <code>n</code> fluorophores per site.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of fluorophores per site</li><li><code>efficiency::Float64</code>: Probability that a site gets labeled at all (0 to 1)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Perfect labeling - exactly 1 fluorophore per site (default/current behavior)
labeling = FixedLabeling()

# 2 fluorophores per site, 90% of sites labeled
labeling = FixedLabeling(2; efficiency=0.9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L22-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.GenericFluor"><a class="docstring-binding" href="#SMLMSim.Core.GenericFluor"><code>SMLMSim.Core.GenericFluor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GenericFluor &lt;: Molecule</code></pre><p>Defines a fluorophore with photophysical properties.</p><p><strong>Fields</strong></p><ul><li><code>γ::AbstractFloat</code>: Photon emission rate in Hz. Default: 1e5</li><li><code>q::Array{&lt;:AbstractFloat}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i. Default: standard 2-state model with on-&gt;off rate of 50Hz and off-&gt;on rate of 1e-2Hz</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a fluorophore with default parameters (using the 2-state keyword constructor)
fluor = GenericFluor()

# Create a fluorophore with custom parameters using the positional constructor
fluor = GenericFluor(1e5, [-50.0 50.0; 1e-2 -1e-2])

# Create a fluorophore using the 2-state keyword constructor
fluor = GenericFluor(; photons=1e5, k_off=10.0, k_on=1e-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/molecules.jl#L11-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.GenericFluor-Tuple{}"><a class="docstring-binding" href="#SMLMSim.Core.GenericFluor-Tuple{}"><code>SMLMSim.Core.GenericFluor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GenericFluor(; photons::AbstractFloat=1e5, k_off::AbstractFloat=50.0, k_on::AbstractFloat=1e-2)</code></pre><p>Create a simple two-state (on/off) fluorophore with specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>photons::AbstractFloat</code>: Photon emission rate in Hz</li><li><code>k_off::AbstractFloat</code>: Off-switching rate (on→off) in Hz</li><li><code>k_on::AbstractFloat</code>: On-switching rate (off→on) in Hz</li></ul><p><strong>Details</strong></p><p>Creates a fluorophore with a 2-state model and the specified rates. State 1 is the on (bright) state, and state 2 is the off (dark) state. The rate matrix is constructed as: q = [-k<em>off k</em>off; k<em>on -k</em>on]</p><p>Note: k<em>on and k</em>off are transition rates (1/s), not duty cycle fractions. The duty cycle (fraction of time in ON state) is k<em>on/(k</em>on + k<em>off). For typical dSTORM, k</em>on &lt;&lt; k_off gives low duty cycle (mostly dark, brief blinks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/molecules.jl#L40-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Line2D"><a class="docstring-binding" href="#SMLMSim.Core.Line2D"><code>SMLMSim.Core.Line2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Line2D &lt;: Pattern2D</code></pre><p>Points with uniform random distribution between two endpoints.</p><p><strong>Fields</strong></p><ul><li><code>λ::Float64</code>: Linear molecule density (molecules per micron)</li><li><code>endpoints::Vector{Tuple{Float64,Float64}}</code>: Vector of endpoint coordinates</li><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a line with default parameters
line = Line2D()

# Create a custom line
line = Line2D(; λ=5.0, endpoints=[(-2.0, 0.0), (2.0, 0.0)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L148-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Line3D"><a class="docstring-binding" href="#SMLMSim.Core.Line3D"><code>SMLMSim.Core.Line3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Line3D &lt;: Pattern3D</code></pre><p>Points with uniform random distribution between two 3D endpoints.</p><p><strong>Fields</strong></p><ul><li><code>λ::Float64</code>: Linear molecule density (molecules per micron)</li><li><code>endpoints::Vector{Tuple{Float64,Float64,Float64}}</code>: Vector of 3D endpoint coordinates</li><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li><li><code>z::Vector{Float64}</code>: Z positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a line with default parameters
line = Line3D()

# Create a custom 3D line
line = Line3D(; λ=5.0, endpoints=[(-1.0, 0.0, -0.5), (1.0, 0.0, 0.5)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L226-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Molecule"><a class="docstring-binding" href="#SMLMSim.Core.Molecule"><code>SMLMSim.Core.Molecule</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Molecule</code></pre><p>Abstract type for representing photophysical properties of a molecule.</p><p>This is the most general type of luminescent or scattering single molecule. Inherited types will define the properties of specific classes of molecules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/molecules.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Nmer2D"><a class="docstring-binding" href="#SMLMSim.Core.Nmer2D"><code>SMLMSim.Core.Nmer2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Nmer2D &lt;: Pattern2D</code></pre><p>N molecules symmetrically organized around a circle with diameter d.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>d::Float64</code>: Diameter of the circle in microns</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an 8-molecule pattern with 100nm diameter
nmer = Nmer2D()

# Create a custom pattern with 6 molecules and 200nm diameter
nmer = Nmer2D(; n=6, d=0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L27-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Nmer3D"><a class="docstring-binding" href="#SMLMSim.Core.Nmer3D"><code>SMLMSim.Core.Nmer3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Nmer3D &lt;: Pattern3D</code></pre><p>N molecules symmetrically organized around a circle with diameter d at z=0.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: Number of molecules in the pattern</li><li><code>d::Float64</code>: Diameter of the circle in microns</li><li><code>x::Vector{Float64}</code>: X positions of molecules in microns</li><li><code>y::Vector{Float64}</code>: Y positions of molecules in microns</li><li><code>z::Vector{Float64}</code>: Z positions of molecules in microns</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an 8-molecule pattern with 100nm diameter
nmer = Nmer3D()

# Create a custom pattern with 6 molecules and 200nm diameter
nmer = Nmer3D(; n=6, d=0.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L85-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Pattern"><a class="docstring-binding" href="#SMLMSim.Core.Pattern"><code>SMLMSim.Core.Pattern</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Pattern</code></pre><p>Abstract type for all molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Pattern2D"><a class="docstring-binding" href="#SMLMSim.Core.Pattern2D"><code>SMLMSim.Core.Pattern2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Pattern2D &lt;: Pattern</code></pre><p>Abstract type for 2D molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.Pattern3D"><a class="docstring-binding" href="#SMLMSim.Core.Pattern3D"><code>SMLMSim.Core.Pattern3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Pattern3D &lt;: Pattern</code></pre><p>Abstract type for 3D molecular spatial patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.PoissonLabeling"><a class="docstring-binding" href="#SMLMSim.Core.PoissonLabeling"><code>SMLMSim.Core.PoissonLabeling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PoissonLabeling &lt;: AbstractLabeling</code></pre><p>Poisson-distributed number of fluorophores per site.</p><p><strong>Fields</strong></p><ul><li><code>mean::Float64</code>: Mean number of fluorophores per site (λ for Poisson)</li><li><code>efficiency::Float64</code>: Probability that a site gets labeled at all (0 to 1)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Average 1.5 fluorophores per site
labeling = PoissonLabeling(1.5)

# Average 2 fluorophores per site, but only 80% of sites get labeled
labeling = PoissonLabeling(2.0; efficiency=0.8)</code></pre><p><strong>Note</strong></p><p>With Poisson statistics, some sites may receive 0 fluorophores even when efficiency=1.0 (especially for small mean values). The efficiency parameter controls a separate &quot;does this site get labeled at all&quot; step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L58-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.SMLMSimParams"><a class="docstring-binding" href="#SMLMSim.Core.SMLMSimParams"><code>SMLMSim.Core.SMLMSimParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SMLMSimParams &lt;: AbstractSMLMConfig</code></pre><p>Abstract type for all SMLM simulation parameter types. Inherits from SMLMData.AbstractSMLMConfig to participate in the ecosystem-wide (Config, Info, Data) tuple pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/abstract_types.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.apply_labeling-Union{Tuple{T}, Tuple{Tuple{Vector{T}, Vector{T}}, AbstractLabeling}} where T"><a class="docstring-binding" href="#SMLMSim.Core.apply_labeling-Union{Tuple{T}, Tuple{Tuple{Vector{T}, Vector{T}}, AbstractLabeling}} where T"><code>SMLMSim.Core.apply_labeling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_labeling(coords, labeling::AbstractLabeling)</code></pre><p>Apply labeling strategy to binding site coordinates without pattern tracking.</p><p>This is a convenience method that returns only the expanded coordinates (for backward compatibility).</p><p><strong>Arguments</strong></p><ul><li><code>coords</code>: Tuple of coordinate vectors <code>(x, y)</code> for 2D or <code>(x, y, z)</code> for 3D</li><li><code>labeling::AbstractLabeling</code>: Labeling strategy to apply</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of coordinate vectors with fluorophore positions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Apply labeling without pattern tracking
x, y = [1.0, 2.0], [3.0, 4.0]
new_x, new_y = apply_labeling((x, y), FixedLabeling(2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L240-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.apply_labeling-Union{Tuple{T}, Tuple{Tuple{Vector{T}, Vector{T}}, Vector{Int64}, AbstractLabeling}} where T"><a class="docstring-binding" href="#SMLMSim.Core.apply_labeling-Union{Tuple{T}, Tuple{Tuple{Vector{T}, Vector{T}}, Vector{Int64}, AbstractLabeling}} where T"><code>SMLMSim.Core.apply_labeling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_labeling(coords, pattern_ids, labeling::AbstractLabeling)</code></pre><p>Apply labeling strategy to binding site coordinates, expanding each site to the appropriate number of fluorophore positions while preserving pattern IDs.</p><p><strong>Arguments</strong></p><ul><li><code>coords</code>: Tuple of coordinate vectors <code>(x, y)</code> for 2D or <code>(x, y, z)</code> for 3D</li><li><code>pattern_ids::Vector{Int}</code>: Pattern instance ID for each binding site</li><li><code>labeling::AbstractLabeling</code>: Labeling strategy to apply</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: (coords, new<em>pattern</em>ids) where coords is a tuple of coordinate vectors and new<em>pattern</em>ids preserves pattern membership for each fluorophore</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Original: binding sites with pattern IDs
x, y, pattern_ids = uniform2D(1.0, Nmer2D(), 10.0, 10.0)

# After Poisson labeling: variable number of fluorophores, pattern IDs preserved
(x_labeled, y_labeled), new_ids = apply_labeling((x, y), pattern_ids, PoissonLabeling(1.5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L175-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.compute_equilibrium_distribution-Tuple{Matrix{&lt;:AbstractFloat}}"><a class="docstring-binding" href="#SMLMSim.Core.compute_equilibrium_distribution-Tuple{Matrix{&lt;:AbstractFloat}}"><code>SMLMSim.Core.compute_equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_equilibrium_distribution(q::Matrix{&lt;:AbstractFloat})</code></pre><p>Calculate the equilibrium probability distribution for a CTMC rate matrix.</p><p><strong>Arguments</strong></p><ul><li><code>q::Matrix{&lt;:AbstractFloat}</code>: Rate matrix where q[i,j] for i≠j is the transition rate from state i to j, and q[i,i] is the negative exit rate from state i</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Equilibrium probabilities for each state</li></ul><p><strong>Details</strong></p><p>For a rate matrix Q, the equilibrium distribution π satisfies π·Q = 0 subject to Σπ = 1. This function solves the linear system directly to find the equilibrium distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/photophysics.jl#L257-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.get_next-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.get_next-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.get_next</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_next(ctmc::CTMC, t::AbstractFloat)</code></pre><p>Get the next state transition after a specific time point.</p><p><strong>Arguments</strong></p><ul><li><code>ctmc::CTMC</code>: The CTMC to query</li><li><code>t::AbstractFloat</code>: Current time point</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int,AbstractFloat}</code>: (next<em>state, transition</em>time)</li></ul><p><strong>Note</strong></p><p>Returns the next state that will be entered and when it will be entered, searching from the current time point forward.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/ctmc.jl#L220-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.get_num_tracks-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.Core.get_num_tracks-Tuple{BasicSMLD}"><code>SMLMSim.Core.get_num_tracks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_num_tracks(smld::BasicSMLD)</code></pre><p>Return the number of unique tracks (based on track_id) in the SMLD.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The SMLD to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of unique track IDs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get the number of tracks
n_tracks = get_num_tracks(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/track_utils.jl#L40-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.get_state-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.get_state-Union{Tuple{T}, Tuple{CTMC{T}, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.get_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_state(ctmc::CTMC, t::AbstractFloat)</code></pre><p>Get the state of the CTMC at a specific time point.</p><p><strong>Arguments</strong></p><ul><li><code>ctmc::CTMC</code>: The CTMC to query</li><li><code>t::AbstractFloat</code>: Time point of interest</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: State of the chain at time t</li></ul><p><strong>Note</strong></p><p>Searches through transition times to find the state active at time t. Returns the state that was entered at the last transition before t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/ctmc.jl#L194-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.get_track-Tuple{BasicSMLD, Int64}"><a class="docstring-binding" href="#SMLMSim.Core.get_track-Tuple{BasicSMLD, Int64}"><code>SMLMSim.Core.get_track</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_track(smld::BasicSMLD, id::Int)</code></pre><p>Return a new SMLD containing only emitters with the specified track_id.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD</li><li><code>id::Int</code>: Track ID to filter by</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters from the specified track</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get all emitters belonging to track 5
track_smld = get_track(smld, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/track_utils.jl#L7-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.get_tracks-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.Core.get_tracks-Tuple{BasicSMLD}"><code>SMLMSim.Core.get_tracks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tracks(smld::BasicSMLD)</code></pre><p>Return a vector of SMLD objects, one for each unique track (based on track_id).</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{BasicSMLD}</code>: Vector of SMLD objects, one per track</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get all tracks as separate SMLD objects
track_smlds = get_tracks(smld)

# Access the first track
first_track = track_smlds[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/track_utils.jl#L68-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.intensity_trace-Tuple{GenericFluor, Int64, Real}"><a class="docstring-binding" href="#SMLMSim.Core.intensity_trace-Tuple{GenericFluor, Int64, Real}"><code>SMLMSim.Core.intensity_trace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intensity_trace(f::GenericFluor, nframes::Int, framerate::Real; state1=1, burn_in=0.0)</code></pre><p>Calculate a fluorescence intensity trace by integrating emission during fluorescent state occupancy.</p><p><strong>Arguments</strong></p><ul><li><code>f::GenericFluor</code>: Fluorophore model containing transition rates (q) and emission rate (γ)</li><li><code>nframes::Int</code>: Number of frames to simulate</li><li><code>framerate::Real</code>: Frame rate in Hz</li><li><code>state1::Int=1</code>: Initial state (default: 1 for fluorescent state)</li><li><code>burn_in::Real=0.0</code>: Pre-illumination time in seconds before recording starts. The CTMC runs for this duration first, allowing the system to reach a pseudo-equilibrium (e.g., some molecules bleach before data collection begins).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Integrated photon counts for each frame</li></ul><p><strong>Details</strong></p><p>For each frame:</p><ol><li>Determines state occupancy using CTMC (which starts at time 0, but recording starts at burn_in)</li><li>Integrates emission (rate f.γ) during fluorescent state periods</li><li>Accumulates photons within frame exposure time (1/framerate)</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">fluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])
photons = intensity_trace(fluor, 1000, 10.0)

# With 5 second burn-in (pre-illumination before recording)
photons = intensity_trace(fluor, 1000, 10.0; burn_in=5.0)</code></pre><p><strong>Note</strong></p><ul><li>State 1 is assumed to be the fluorescent state</li><li>Emission only occurs in state 1 with rate f.γ</li><li>Frame exposure is assumed to be 1/framerate (100% duty cycle)</li><li>burn_in is useful for models with photobleaching to simulate pre-illumination</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/photophysics.jl#L12-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.kinetic_model-Tuple{BasicSMLD, Molecule, Int64, Real}"><a class="docstring-binding" href="#SMLMSim.Core.kinetic_model-Tuple{BasicSMLD, Molecule, Int64, Real}"><code>SMLMSim.Core.kinetic_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kinetic_model(smld::BasicSMLD, f::Molecule, nframes::Int, framerate::Real;
             ndatasets::Int=1, minphotons=50.0, state1::Union{Int, Symbol}=:equilibrium,
             burn_in::Real=0.0)</code></pre><p>Generate kinetic blinking model from existing localization data.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing true emitter positions</li><li><code>f::Molecule</code>: Fluorophore model with kinetic rates</li><li><code>nframes::Int</code>: Number of frames to simulate</li><li><code>framerate::Real</code>: Frame rate in Hz</li><li><code>ndatasets::Int=1</code>: Number of independent datasets to generate</li><li><code>minphotons::Float64=50.0</code>: Minimum photons for detection</li><li><code>state1::Union{Int, Symbol}=:equilibrium</code>: Initial state specification:<ul><li><code>::Int</code>: Specific state to start in (1=on, 2=off typically)</li><li><code>:equilibrium</code>: Sample from equilibrium distribution (default)</li></ul></li><li><code>burn_in::Real=0.0</code>: Pre-illumination time in seconds before recording starts. Simulates the common experimental protocol where high laser power is applied for several seconds before data collection begins, allowing some molecules to bleach and others to reach a pseudo-equilibrium blinking state.</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with simulated blinking kinetics</li></ul><p><strong>Details</strong></p><p>For each unique position in the input SMLD:</p><ol><li>Simulates fluorophore blinking using the kinetic model</li><li>Creates emitters for frames where photon count exceeds threshold</li><li>Preserves track_id for linking emitters from same position</li><li>Maintains camera and extends metadata from input SMLD</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">camera = IdealCamera(1:128, 1:128, 0.1)
pattern = Nmer2D()
smld_true, _, _ = simulate(pattern=pattern, camera=camera)

# Add blinking kinetics
fluor = GenericFluor(; γ=10000.0, q=[-10.0 10.0; 1e-1 -1e-1])
smld_model = kinetic_model(smld_true, fluor, 1000, 10.0)

# With 5 second burn-in to simulate pre-illumination
smld_model = kinetic_model(smld_true, fluor, 1000, 10.0; burn_in=5.0)</code></pre><p><strong>Note</strong></p><p>The emitter type (2D/3D) is automatically determined from the input SMLD. Position uncertainties are initialized to 0 and can be set using the apply_noise() function. For models with photobleaching (absorbing states), use <code>state1=1</code> instead of <code>:equilibrium</code> since absorbing states have no true equilibrium.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/photophysics.jl#L88-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.n_fluorophores-Tuple{FixedLabeling}"><a class="docstring-binding" href="#SMLMSim.Core.n_fluorophores-Tuple{FixedLabeling}"><code>SMLMSim.Core.n_fluorophores</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_fluorophores(labeling::AbstractLabeling) -&gt; Int</code></pre><p>Sample the number of fluorophores to place at a single binding site.</p><p>This function is called once per binding site during labeling. It first checks labeling efficiency (probability site gets labeled at all), then samples from the appropriate distribution.</p><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of fluorophores (can be 0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/labeling.jl#L144-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern2D, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern2D, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern2D, θ::Float64)</code></pre><p>Rotate a 2D pattern by angle θ (in radians).</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern2D</code>: Pattern to rotate</li><li><code>θ::Float64</code>: Rotation angle in radians</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer2D()
rotate!(nmer, π/4)  # Rotate 45 degrees</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L464-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, Matrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, Matrix{T}}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern3D, R::Matrix{Float64})</code></pre><p>Rotate a 3D pattern by rotation matrix R.</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern3D</code>: Pattern to rotate</li><li><code>R::Matrix{Float64}</code>: 3x3 rotation matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer3D()
# Create a rotation matrix for 90 degrees around z-axis
θ = π/2
R = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]
rotate!(nmer, R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L489-L506">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, T, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.Core.rotate!-Union{Tuple{T}, Tuple{Pattern3D, T, T, T}} where T&lt;:AbstractFloat"><code>SMLMSim.Core.rotate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate!(p::Pattern3D, α::Float64, β::Float64, γ::Float64)</code></pre><p>Rotate a 3D pattern by Euler angles α, β, γ (in radians). Uses ZYZ convention.</p><p><strong>Arguments</strong></p><ul><li><code>p::Pattern3D</code>: Pattern to rotate</li><li><code>α::Float64</code>: First rotation angle (around Z axis)</li><li><code>β::Float64</code>: Second rotation angle (around Y&#39; axis)</li><li><code>γ::Float64</code>: Third rotation angle (around Z&#39;&#39; axis)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nmer = Nmer3D()
rotate!(nmer, π/4, π/6, π/3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L521-L538">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.sample_discrete-Tuple{Vector{&lt;:AbstractFloat}}"><a class="docstring-binding" href="#SMLMSim.Core.sample_discrete-Tuple{Vector{&lt;:AbstractFloat}}"><code>SMLMSim.Core.sample_discrete</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_discrete(p::Vector{&lt;:AbstractFloat})</code></pre><p>Sample from a discrete probability distribution.</p><p><strong>Arguments</strong></p><ul><li><code>p::Vector{&lt;:AbstractFloat}</code>: Probability distribution</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Sampled state index</li></ul><p><strong>Details</strong></p><p>Samples a state index i with probability p[i] using the inverse CDF method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/photophysics.jl#L306-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.sample_discrete_with_probs-Tuple{Any, Any}"><a class="docstring-binding" href="#SMLMSim.Core.sample_discrete_with_probs-Tuple{Any, Any}"><code>SMLMSim.Core.sample_discrete_with_probs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_discrete_with_probs(indices, probs)</code></pre><p>Sample a discrete value from indices with corresponding probabilities.</p><p><strong>Arguments</strong></p><ul><li><code>indices::Vector{Int}</code>: Vector of possible indices to sample</li><li><code>probs::Vector{&lt;:AbstractFloat}</code>: Corresponding probabilities</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Sampled index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/ctmc.jl#L170-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.uniform2D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern2D, T2, T3}} where {T1&lt;:AbstractFloat, T2&lt;:AbstractFloat, T3&lt;:AbstractFloat}"><a class="docstring-binding" href="#SMLMSim.Core.uniform2D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern2D, T2, T3}} where {T1&lt;:AbstractFloat, T2&lt;:AbstractFloat, T3&lt;:AbstractFloat}"><code>SMLMSim.Core.uniform2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uniform2D(ρ::Float64, p::Pattern2D, field_x::Float64, field_y::Float64)</code></pre><p>Create coordinate arrays for randomly placed and rotated 2D patterns.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Float64</code>: Pattern density (patterns per square micron)</li><li><code>p::Pattern2D</code>: Pattern to replicate</li><li><code>field_x::Float64</code>: Field width in microns</li><li><code>field_y::Float64</code>: Field height in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}, Vector{Int}}</code>: (x, y, pattern<em>ids) where pattern</em>ids indicates which pattern instance each point belongs to</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate coordinates for randomly placed Nmer2D patterns
nmer = Nmer2D(; n=6, d=0.2)
x, y, pattern_ids = uniform2D(1.0, nmer, 10.0, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L314-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.Core.uniform3D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern3D, T2, T3}} where {T1&lt;:AbstractFloat, T2&lt;:AbstractFloat, T3&lt;:AbstractFloat}"><a class="docstring-binding" href="#SMLMSim.Core.uniform3D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, Pattern3D, T2, T3}} where {T1&lt;:AbstractFloat, T2&lt;:AbstractFloat, T3&lt;:AbstractFloat}"><code>SMLMSim.Core.uniform3D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uniform3D(ρ::Float64, p::Pattern3D, field_x::Float64, field_y::Float64;
         zrange::Vector{Float64}=[-1.0, 1.0])</code></pre><p>Create coordinate arrays for randomly placed and rotated 3D patterns.</p><p><strong>Arguments</strong></p><ul><li><code>ρ::Float64</code>: Pattern density (patterns per square micron)</li><li><code>p::Pattern3D</code>: Pattern to replicate</li><li><code>field_x::Float64</code>: Field width in microns</li><li><code>field_y::Float64</code>: Field height in microns</li><li><code>zrange::Vector{Float64}=[-1.0, 1.0]</code>: [min<em>z, max</em>z] range in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Int}}</code>: (x, y, z, pattern<em>ids) where pattern</em>ids indicates which pattern instance each point belongs to</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate coordinates for randomly placed Nmer3D patterns
nmer = Nmer3D(; n=6, d=0.2)
x, y, z, pattern_ids = uniform3D(1.0, nmer, 10.0, 10.0; zrange=[-2.0, 2.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/core/patterns.jl#L372-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.StaticSMLM"><a class="docstring-binding" href="#SMLMSim.StaticSMLM"><code>SMLMSim.StaticSMLM</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">StaticSMLM</code></pre><p>Module for simulating static (non-diffusing) SMLM data with blinking kinetics.</p><p>This module provides functionality for:</p><ol><li>Generating spatial distributions of emitters based on patterns</li><li>Simulating fluorophore blinking based on stochastic kinetic models</li><li>Adding realistic localization uncertainties</li><li>Creating complete SMLM datasets</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.StaticSMLM</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/StaticSMLM.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.StaticSMLM.StaticSMLMConfig"><a class="docstring-binding" href="#SMLMSim.StaticSMLM.StaticSMLMConfig"><code>SMLMSim.StaticSMLM.StaticSMLMConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StaticSMLMConfig &lt;: SMLMSimParams</code></pre><p>Parameters for static SMLM simulation.</p><p><strong>Fields</strong></p><ul><li><code>density::Float64</code>: density in particles per square micron</li><li><code>σ_psf::Float64</code>: PSF width in microns</li><li><code>minphotons::Int</code>: minimum photons for detection</li><li><code>ndatasets::Int</code>: number of datasets to simulate</li><li><code>nframes::Int</code>: number of frames per dataset</li><li><code>framerate::Float64</code>: frames per second</li><li><code>ndims::Int</code>: dimensionality (2 or 3)</li><li><code>zrange::Vector{Float64}</code>: axial range for 3D simulations [min<em>z, max</em>z]</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default parameters
params = StaticSMLMConfig()

# Custom parameters
params = StaticSMLMConfig(
    density = 2.0,              # 2 particles per μm²
    σ_psf = 0.15,         # 150nm PSF width
    minphotons = 100,     # minimum photons for detection
    ndatasets = 5,        # 5 independent datasets
    nframes = 2000,       # 2000 frames per dataset
    framerate = 100.0,    # 100 frames per second
    ndims = 3,            # 3D simulation
    zrange = [-2.0, 2.0]  # 4μm axial range
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/parameters.jl#L1-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.StaticSMLM.add_coordinate_noise-Tuple{Emitter2DFit, AbstractFloat}"><a class="docstring-binding" href="#SMLMSim.StaticSMLM.add_coordinate_noise-Tuple{Emitter2DFit, AbstractFloat}"><code>SMLMSim.StaticSMLM.add_coordinate_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_coordinate_noise(emitter, σ)</code></pre><p>Helper function to add position noise to an emitter with appropriate uncertainty. Returns new coordinate values and uncertainty values.</p><p>For 2D emitters, σ is a scalar. For 3D emitters, σ is a 3-element vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/coordinate_noise.jl#L8-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, AbstractFloat}"><a class="docstring-binding" href="#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, AbstractFloat}"><code>SMLMSim.StaticSMLM.apply_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_noise(smld::BasicSMLD, σ_psf::AbstractFloat)</code></pre><p>Add localization uncertainty to 2D emitter positions based on photon counts.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing 2D emitters</li><li><code>σ_psf::AbstractFloat</code>: PSF width in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with noisy positions and updated uncertainties</li></ul><p><strong>Note</strong></p><p>For symmetric (axis-aligned) PSFs, σ_xy covariance is set to 0.0. This is the physically correct value, not a placeholder. Rotated/tilted PSFs would require additional parameters to compute non-zero covariance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Then add localization noise with specific PSF width
smld_noisy = apply_noise(smld_model, 0.13)  # 130nm PSF width</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/coordinate_noise.jl#L40-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, Vector{&lt;:AbstractFloat}}"><a class="docstring-binding" href="#SMLMSim.StaticSMLM.apply_noise-Tuple{BasicSMLD, Vector{&lt;:AbstractFloat}}"><code>SMLMSim.StaticSMLM.apply_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_noise(smld::BasicSMLD, σ_psf::Vector{&lt;:AbstractFloat})</code></pre><p>Add localization uncertainty to 3D emitter positions based on photon counts.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Input SMLD containing 3D emitters</li><li><code>σ_psf::Vector{&lt;:AbstractFloat}</code>: PSF widths [σx, σy, σz] in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD with noisy positions and updated uncertainties</li></ul><p><strong>Note</strong></p><p>For symmetric (axis-aligned) PSFs, σ_xy covariance is set to 0.0. This is the physically correct value, not a placeholder. Rotated/tilted PSFs would require additional parameters to compute non-zero covariance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Then add localization noise with specific PSF widths
σ_psf = [0.13, 0.13, 0.39]  # 130nm lateral, 390nm axial
smld_noisy = apply_noise(smld_model, σ_psf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/coordinate_noise.jl#L109-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.simulate-Tuple{StaticSMLMConfig}"><a class="docstring-binding" href="#SMLMSim.simulate-Tuple{StaticSMLMConfig}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate(params::StaticSMLMConfig;
         starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractEmitter}}=nothing,
         pattern::Pattern=nothing,
         labeling::AbstractLabeling=FixedLabeling(),
         molecule::Molecule=GenericFluor(photons=1e4, k_off=50.0, k_on=1e-2),
         camera::AbstractCamera=IdealCamera(1:128, 1:128, 0.1),
         state1::Union{Int, Symbol}=:equilibrium,
         burn_in::Real=0.0)</code></pre><p>Generate simulated static SMLM data with realistic blinking kinetics and localization uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>params::StaticSMLMConfig</code>: Simulation parameters</li><li><code>starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractEmitter}}</code>: Optional starting conditions instead of generating patterns</li><li><code>pattern::Pattern</code>: Pattern to use (default depends on params.ndims)</li><li><code>labeling::AbstractLabeling</code>: Labeling strategy for fluorophore attachment (default: FixedLabeling() = 1 per site)</li><li><code>molecule::Molecule</code>: Fluorophore model for blinking simulation</li><li><code>camera::AbstractCamera</code>: Camera model for detection simulation</li><li><code>state1::Union{Int, Symbol}=:equilibrium</code>: Initial fluorophore state:<ul><li><code>::Int</code>: Specific state (1=on, 2=off typically)</li><li><code>:equilibrium</code>: Sample from equilibrium distribution (default)</li></ul>For models with photobleaching (absorbing states), use <code>state1=1</code>.</li><li><code>burn_in::Real=0.0</code>: Pre-illumination time in seconds before recording starts. Simulates experimental protocol where laser is on before data collection, allowing some molecules to bleach and reach pseudo-equilibrium.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{BasicSMLD, SimInfo}</code>: (noisy_data, info)<ul><li>noisy_data: Positions with blinking and localization uncertainty</li><li>info: SimInfo containing smld<em>true, smld</em>model, timing, and counts</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create parameters
params = StaticSMLMConfig(
    density = 2.0,              # 2 patterns per μm²
    σ_psf = 0.15,         # 150nm PSF width
    minphotons = 100,     # 100 photons for detection
    ndatasets = 5,        # 5 independent datasets
    nframes = 2000,       # 2000 frames
    framerate = 100.0     # 100 frames per second
)

# Run simulation with Nmer pattern
pattern = Nmer3D(n=6, d=0.2)
smld_noisy, info = simulate(params; pattern=pattern)

# Access intermediate results
smld_true = info.smld_true
smld_model = info.smld_model

# Run with Poisson labeling (average 1.5 fluorophores per binding site)
smld_noisy, info = simulate(params;
    pattern=pattern,
    labeling=PoissonLabeling(1.5)
)

# Run with partial labeling efficiency (80% of sites labeled)
smld_noisy, info = simulate(params;
    pattern=pattern,
    labeling=PoissonLabeling(1.0; efficiency=0.8)
)

# Run with photobleaching model and 5s burn-in
k_off, k_on, k_bleach = 10.0, 1.0, 0.1
Q = [-(k_off+k_bleach) k_off k_bleach; k_on -k_on 0.0; 0.0 0.0 0.0]
fluor = GenericFluor(1e4, Q)
smld_noisy, info = simulate(params;
    molecule=fluor,
    state1=1,        # Start in ON state (required for absorbing states)
    burn_in=5.0      # 5 seconds pre-illumination
)

# Run with custom starting conditions (labeling not applied)
custom_emitters = [
    Emitter2DFit{Float64}(x, y, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0; σ_xy=0.0, track_id=i)
    for (i, (x, y)) in enumerate(zip(rand(10), rand(10)))
]
smld_noisy, info = simulate(params; starting_conditions=custom_emitters)</code></pre><p><strong>Note</strong></p><ul><li>The <code>params.σ_psf</code> value is used directly for lateral uncertainty (σx, σy) in both 2D and 3D.</li><li>For 3D simulations, the axial uncertainty (σz) is scaled by a factor of 3 (i.e., σz = 3 * σ_psf).</li><li>If <code>starting_conditions</code> is provided, it will be used instead of generating patterns, and labeling is not applied.</li><li>Labeling and molecule are separate concepts: labeling controls how many fluorophores per binding site, molecule controls the photophysics (blinking) of each fluorophore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/static/simulation.jl#L5-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion"><code>SMLMSim.InteractionDiffusion</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">InteractionDiffusion</code></pre><p>This module provides simulation tools for diffusion and interaction between particles.</p><p><strong>Overview</strong></p><p>Simulates diffusion and interaction dynamics between particles in 2D/3D space. Includes functionality for generating microscope images, analyzing dimers, and visualizing particle dynamics.</p><p><strong>Components</strong></p><ul><li>Abstract and concrete emitter types (AbstractDiffusingEmitter, DiffusingEmitter2D, DiffusingEmitter3D)</li><li>Smoluchowski dynamics simulation</li><li>Analysis tools for dimers and state transitions</li><li>SMLD conversion utilities</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Set up simulation parameters
params = DiffusionSMLMConfig(
    density = 0.5,            # molecules per μm²
    box_size = 10.0,          # μm
    diff_monomer = 0.1,       # μm²/s
    diff_dimer = 0.05,        # μm²/s
    k_off = 0.2,              # s⁻¹
    r_react = 0.01,           # μm
    d_dimer = 0.05,           # μm
    dt = 0.01,                # s
    t_max = 10.0,             # s
    camera_framerate = 20.0,  # fps
    camera_exposure = 0.04    # s
)

# Run simulation - returns a single SMLD with all emitters
smld = simulate(params)

# Generate images for microscopy
psf = GaussianPSF(0.15)  # 150nm PSF width
images = gen_images(psf, smld)

# Analyze results
dimer_smld = get_dimers(smld)
frames, dimer_fractions = analyze_dimer_fraction(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/InteractionDiffusion.jl#L1-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter"><code>SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDiffusingEmitter &lt;: AbstractEmitter</code></pre><p>Abstract type for all diffusing emitters to enable dispatch-based operations. This provides a common parent for 2D and 3D diffusing emitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/types.jl#L4-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.DiffusingEmitter2D"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.DiffusingEmitter2D"><code>SMLMSim.InteractionDiffusion.DiffusingEmitter2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiffusingEmitter2D{T&lt;:AbstractFloat} &lt;: AbstractDiffusingEmitter</code></pre><p>A 2D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: x-coordinate in microns</li><li><code>y::T</code>: y-coordinate in microns</li><li><code>photons::T</code>: number of photons emitted</li><li><code>timestamp::T</code>: actual simulation time in seconds</li><li><code>frame::Int</code>: camera frame number based on framerate and exposure</li><li><code>dataset::Int</code>: dataset identifier</li><li><code>track_id::Int</code>: unique molecule identifier </li><li><code>state::Symbol</code>: molecular state (:monomer or :dimer)</li><li><code>partner_id::Union{Int,Nothing}</code>: ID of linked molecule (for dimers), or nothing for monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/types.jl#L12-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.DiffusingEmitter3D"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.DiffusingEmitter3D"><code>SMLMSim.InteractionDiffusion.DiffusingEmitter3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiffusingEmitter3D{T&lt;:AbstractFloat} &lt;: AbstractDiffusingEmitter</code></pre><p>A 3D emitter type for diffusion simulations that contains both spatial and temporal information, plus molecular state information.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: x-coordinate in microns</li><li><code>y::T</code>: y-coordinate in microns</li><li><code>z::T</code>: z-coordinate in microns</li><li><code>photons::T</code>: number of photons emitted</li><li><code>timestamp::T</code>: actual simulation time in seconds</li><li><code>frame::Int</code>: camera frame number based on framerate and exposure</li><li><code>dataset::Int</code>: dataset identifier</li><li><code>track_id::Int</code>: unique molecule identifier</li><li><code>state::Symbol</code>: molecular state (:monomer or :dimer)</li><li><code>partner_id::Union{Int,Nothing}</code>: ID of linked molecule (for dimers), or nothing for monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/types.jl#L48-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.DiffusionSMLMConfig"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.DiffusionSMLMConfig"><code>SMLMSim.InteractionDiffusion.DiffusionSMLMConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiffusionSMLMConfig &lt;: SMLMSimParams</code></pre><p>Parameters for diffusion-based SMLM simulation using Smoluchowski dynamics.</p><p><strong>Fields</strong></p><ul><li><code>density::Float64</code>: number density (molecules/μm²)</li><li><code>box_size::Float64</code>: simulation box size (μm)</li><li><code>diff_monomer::Float64</code>: monomer diffusion coefficient (μm²/s)</li><li><code>diff_dimer::Float64</code>: dimer diffusion coefficient (μm²/s)</li><li><code>diff_dimer_rot::Float64</code>: dimer rotational diffusion coefficient (rad²/s)</li><li><code>k_off::Float64</code>: dimer dissociation rate (s⁻¹)</li><li><code>r_react::Float64</code>: reaction radius (μm)</li><li><code>d_dimer::Float64</code>: monomer separation in dimer (μm)</li><li><code>dt::Float64</code>: time step (s)</li><li><code>t_max::Float64</code>: total simulation time (s)</li><li><code>ndims::Int</code>: number of dimensions (2 or 3)</li><li><code>boundary::String</code>: boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li><li><code>camera_framerate::Float64</code>: camera frames per second (Hz)</li><li><code>camera_exposure::Float64</code>: camera exposure time per frame (s)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default parameters
params = DiffusionSMLMConfig()

# Custom parameters
params = DiffusionSMLMConfig(
    density = 1.0,           # 1 molecule per μm²
    box_size = 20.0,         # 20μm × 20μm box
    diff_monomer = 0.2,      # 0.2 μm²/s
    diff_dimer = 0.1,        # 0.1 μm²/s
    diff_dimer_rot = 0.8,    # 0.8 rad²/s
    k_off = 0.1,             # 0.1 s⁻¹
    r_react = 0.02,          # 20nm reaction radius
    d_dimer = 0.06,          # 60nm dimer separation
    dt = 0.005,              # 5ms time step
    t_max = 20.0,            # 20s simulation
    ndims = 3,               # 3D simulation
    boundary = &quot;reflecting&quot;, # reflecting boundaries
    camera_framerate = 20.0, # 20 frames per second
    camera_exposure = 0.04   # 40ms exposure per frame
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L1-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{DiffusingEmitter2D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#Base.copy-Union{Tuple{DiffusingEmitter2D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(e::DiffusingEmitter2D)</code></pre><p>Create a copy of a 2D diffusing emitter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/types.jl#L116-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{DiffusingEmitter3D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#Base.copy-Union{Tuple{DiffusingEmitter3D{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(e::DiffusingEmitter3D)</code></pre><p>Create a copy of a 3D diffusing emitter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/types.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.add_camera_frame_emitters!-Tuple{Any, Any, Any, Any, DiffusionSMLMConfig}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.add_camera_frame_emitters!-Tuple{Any, Any, Any, Any, DiffusionSMLMConfig}"><code>SMLMSim.InteractionDiffusion.add_camera_frame_emitters!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_camera_frame_emitters!(camera_emitters, emitters, time, frame_num, params)</code></pre><p>Add emitters to camera frames when they fall within an exposure window.</p><p><strong>Arguments</strong></p><ul><li><code>camera_emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Collection of emitters for camera frames</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Current emitters from simulation</li><li><code>time::Float64</code>: Current simulation time</li><li><code>frame_num::Int</code>: Current frame number</li><li><code>params::DiffusionSMLMConfig</code>: Simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L286-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.analyze_dimer_fraction-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.analyze_dimer_fraction-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.analyze_dimer_fraction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">analyze_dimer_fraction(smld::BasicSMLD)</code></pre><p>Calculate the fraction of dimers per frame.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Int}, Vector{Float64}}</code>: Frame numbers and dimer fractions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Calculate dimer fraction over time
frames, fractions = analyze_dimer_fraction(smld)
plot(frames, fractions, xlabel=&quot;Frame&quot;, ylabel=&quot;Dimer Fraction&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L100-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.analyze_dimer_lifetime-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.analyze_dimer_lifetime-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.analyze_dimer_lifetime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">analyze_dimer_lifetime(smld::BasicSMLD)</code></pre><p>Calculate the average lifetime of dimers.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Average dimer lifetime in seconds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L201-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.apply_boundary-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, String}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.apply_boundary-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, String}"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_boundary(e::AbstractDiffusingEmitter, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to an emitter (generic fallback).</p><p><strong>Arguments</strong></p><ul><li><code>e::AbstractDiffusingEmitter</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractDiffusingEmitter</code>: Emitter with boundary conditions applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L543-L555">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, String}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, String}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_boundary(e::DiffusingEmitter2D, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to a 2D emitter.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter2D</code>: New emitter with position constrained to the box</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L560-L572">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, String}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.apply_boundary-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, String}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.apply_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_boundary(e::DiffusingEmitter3D, box_size::Float64, boundary::String)</code></pre><p>Apply boundary conditions to a 3D emitter.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter to apply boundary to</li><li><code>box_size::Float64</code>: Simulation box size in microns</li><li><code>boundary::String</code>: Boundary condition type (&quot;periodic&quot; or &quot;reflecting&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter3D</code>: New emitter with position constrained to the box</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L611-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.can_dimerize-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.can_dimerize-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64}"><code>SMLMSim.InteractionDiffusion.can_dimerize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">can_dimerize(e1::AbstractDiffusingEmitter, e2::AbstractDiffusingEmitter, r_react::Float64)</code></pre><p>Check if two emitters can form a dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e1::AbstractDiffusingEmitter</code>: First emitter</li><li><code>e2::AbstractDiffusingEmitter</code>: Second emitter</li><li><code>r_react::Float64</code>: Reaction radius in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: True if emitters can form a dimer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L92-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters"><code>SMLMSim.InteractionDiffusion.convert_to_diffusing_emitters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">convert_to_diffusing_emitters(emitters::Vector{&lt;:AbstractEmitter}, photons::Float64=1000.0, state::Symbol=:monomer)</code></pre><p>Convert regular emitters to diffusing emitters for use as starting conditions.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractEmitter}</code>: Vector of static emitters to convert</li><li><code>photons::Float64=1000.0</code>: Number of photons to assign</li><li><code>state::Symbol=:monomer</code>: Initial state (:monomer or :dimer)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Vector of diffusing emitters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Convert static emitters to diffusing emitters
static_emitters = smld_static.emitters
diffusing_emitters = convert_to_diffusing_emitters(static_emitters)

# Use as starting conditions for a diffusion simulation
params = DiffusionSMLMConfig(t_max=10.0)
smld = simulate(params; starting_conditions=diffusing_emitters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L513-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.create_smld-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, SMLMData.AbstractCamera, DiffusionSMLMConfig}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.create_smld-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, SMLMData.AbstractCamera, DiffusionSMLMConfig}"><code>SMLMSim.InteractionDiffusion.create_smld</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_smld(emitters::Vector{&lt;:AbstractDiffusingEmitter}, camera::AbstractCamera, params::DiffusionSMLMConfig)</code></pre><p>Convert a collection of diffusing emitters to a BasicSMLD object.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Collection of emitters from simulation</li><li><code>camera::AbstractCamera</code>: Camera model for imaging</li><li><code>params::DiffusionSMLMConfig</code>: Simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: SMLD containing all emitters for further analysis or visualization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L671-L683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diffuse(e::DiffusingEmitter2D, diff_coef::Float64, dt::Float64)</code></pre><p>Create a new emitter with updated position based on Brownian motion.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter to update</li><li><code>diff_coef::Float64</code>: Diffusion coefficient (μm²/s)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter2D</code>: New emitter with updated position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L337-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.diffuse-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Float64, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diffuse(e::DiffusingEmitter3D, diff_coef::Float64, dt::Float64)</code></pre><p>Create a new 3D emitter with updated position based on Brownian motion.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter to update</li><li><code>diff_coef::Float64</code>: Diffusion coefficient (μm²/s)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>DiffusingEmitter3D</code>: New emitter with updated position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L370-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse_dimer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diffuse_dimer(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)</code></pre><p>Diffuse a dimer with both translational and rotational components.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter2D</code>: First emitter in dimer</li><li><code>e2::DiffusingEmitter2D</code>: Second emitter in dimer</li><li><code>diff_trans::Float64</code>: Translational diffusion coefficient (μm²/s)</li><li><code>diff_rot::Float64</code>: Rotational diffusion coefficient (rad²/s)</li><li><code>d_dimer::Float64</code>: Dimer separation distance (μm)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters with updated positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L404-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.diffuse_dimer-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Vararg{Float64, 4}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.diffuse_dimer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diffuse_dimer(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, diff_trans::Float64, diff_rot::Float64, d_dimer::Float64, dt::Float64)</code></pre><p>Diffuse a 3D dimer with both translational and rotational components.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter3D</code>: First emitter in dimer</li><li><code>e2::DiffusingEmitter3D</code>: Second emitter in dimer</li><li><code>diff_trans::Float64</code>: Translational diffusion coefficient (μm²/s)</li><li><code>diff_rot::Float64</code>: Rotational diffusion coefficient (rad²/s)</li><li><code>d_dimer::Float64</code>: Dimer separation distance (μm)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters with updated positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L470-L485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Float64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, DiffusingEmitter2D{T}, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dimerize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimerize(e1::DiffusingEmitter2D, e2::DiffusingEmitter2D, d_dimer::Float64)</code></pre><p>Create two new emitters in dimer state from two monomers.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter2D</code>: First emitter</li><li><code>e2::DiffusingEmitter2D</code>: Second emitter</li><li><code>d_dimer::Float64</code>: Dimer separation distance in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters in dimer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L111-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Float64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.dimerize-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, DiffusingEmitter3D{T}, Float64}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dimerize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimerize(e1::DiffusingEmitter3D, e2::DiffusingEmitter3D, d_dimer::Float64)</code></pre><p>Create two new emitters in dimer state from two monomers in 3D.</p><p><strong>Arguments</strong></p><ul><li><code>e1::DiffusingEmitter3D</code>: First emitter</li><li><code>e2::DiffusingEmitter3D</code>: Second emitter</li><li><code>d_dimer::Float64</code>: Dimer separation distance in microns</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters in dimer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L163-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter2D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dissociate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dissociate(e::DiffusingEmitter2D, emitters::Vector{&lt;:AbstractDiffusingEmitter})</code></pre><p>Create two new monomers from a dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter2D</code>: Emitter part of a dimer</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: All emitters in the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter2D, DiffusingEmitter2D}</code>: Two new emitters in monomer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L234-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.dissociate-Union{Tuple{T}, Tuple{DiffusingEmitter3D{T}, Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}}} where T&lt;:AbstractFloat"><code>SMLMSim.InteractionDiffusion.dissociate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dissociate(e::DiffusingEmitter3D, emitters::Vector{&lt;:AbstractDiffusingEmitter})</code></pre><p>Create two new monomers from a 3D dimer.</p><p><strong>Arguments</strong></p><ul><li><code>e::DiffusingEmitter3D</code>: Emitter part of a dimer</li><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: All emitters in the system</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{DiffusingEmitter3D, DiffusingEmitter3D}</code>: Two new emitters in monomer state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L285-L296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.extract_final_state-Tuple{SMLMData.AbstractSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.extract_final_state-Tuple{SMLMData.AbstractSMLD}"><code>SMLMSim.InteractionDiffusion.extract_final_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_final_state(smld::SMLD)</code></pre><p>Extract the emitters from the final frame of a simulation to use as starting conditions.</p><p><strong>Arguments</strong></p><ul><li><code>smld::SMLD</code>: SMLD containing emitters from a simulation</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractEmitter}</code>: Emitters from the final frame</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run a simulation
params = DiffusionSMLMConfig(t_max=5.0)
smld = simulate(params)

# Extract final state
final_state = extract_final_state(smld)

# Continue simulation with new parameters
params_new = DiffusionSMLMConfig(t_max=10.0, diff_monomer=0.2)
smld_continued = simulate(params_new; starting_conditions=final_state)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L575-L599">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.filter_by_state-Tuple{BasicSMLD, Symbol}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.filter_by_state-Tuple{BasicSMLD, Symbol}"><code>SMLMSim.InteractionDiffusion.filter_by_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter_by_state(smld::BasicSMLD, state::Symbol)</code></pre><p>Filter emitters by their state (monomer or dimer).</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: The original SMLD with diffusing emitters</li><li><code>state::Symbol</code>: State to filter by (:monomer or :dimer)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters with the specified state</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get only monomers
monomer_smld = filter_by_state(smld, :monomer)

# Get only dimers
dimer_smld = filter_by_state(smld, :dimer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L65-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.get_dimers-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.get_dimers-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.get_dimers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dimers(smld::BasicSMLD)</code></pre><p>Extract a new BasicSMLD containing only emitters in dimer state.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Original SMLD with all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only dimers</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Extract only dimers from simulation results
smld = simulate(params)
dimer_smld = get_dimers(smld)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L8-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.get_frame-Tuple{BasicSMLD, Int64}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.get_frame-Tuple{BasicSMLD, Int64}"><code>SMLMSim.InteractionDiffusion.get_frame</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_frame(smld::BasicSMLD, frame_num::Int)</code></pre><p>Extract emitters from a specific frame.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li><li><code>frame_num::Int</code>: Frame number to extract</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only emitters from the specified frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L706-L717">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.get_monomers-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.get_monomers-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.get_monomers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_monomers(smld::BasicSMLD)</code></pre><p>Extract a new BasicSMLD containing only emitters in monomer state.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: Original SMLD with all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSMLD</code>: New SMLD containing only monomers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L40-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.initialize_emitters"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.initialize_emitters"><code>SMLMSim.InteractionDiffusion.initialize_emitters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_emitters(params::DiffusionSMLMConfig, photons::Float64=1000.0; override_count::Union{Nothing, Int}=nothing)</code></pre><p>Create initial emitter positions for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>params::DiffusionSMLMConfig</code>: Simulation parameters</li><li><code>photons::Float64=1000.0</code>: Number of photons per emitter</li><li><code>override_count::Union{Nothing, Int}=nothing</code>: Optional override for the number of molecules</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Vector of initialized emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L120-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.should_dissociate-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, Float64}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.should_dissociate-Tuple{SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter, Float64, Float64}"><code>SMLMSim.InteractionDiffusion.should_dissociate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">should_dissociate(e::AbstractDiffusingEmitter, k_off::Float64, dt::Float64)</code></pre><p>Check if a dimer should dissociate based on stochastic rate.</p><p><strong>Arguments</strong></p><ul><li><code>e::AbstractDiffusingEmitter</code>: Emitter to check</li><li><code>k_off::Float64</code>: Dissociation rate (s⁻¹)</li><li><code>dt::Float64</code>: Time step (s)</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: True if dimer should dissociate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/helpers.jl#L217-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.track_state_changes-Tuple{BasicSMLD}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.track_state_changes-Tuple{BasicSMLD}"><code>SMLMSim.InteractionDiffusion.track_state_changes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">track_state_changes(smld::BasicSMLD)</code></pre><p>Track state changes of molecules over time.</p><p><strong>Arguments</strong></p><ul><li><code>smld::BasicSMLD</code>: SMLD containing all emitters</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int, Vector{Tuple{Int, Symbol}}}</code>: Dictionary mapping molecule IDs to vectors of (frame, state) pairs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Track state changes of molecules
state_history = track_state_changes(smld)

# Plot state history for molecule 1
history = state_history[1]
frames = [h[1] for h in history]
states = [h[2] for h in history]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/analysis.jl#L145-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.InteractionDiffusion.update_system-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, DiffusionSMLMConfig, Float64}"><a class="docstring-binding" href="#SMLMSim.InteractionDiffusion.update_system-Tuple{Vector{&lt;:SMLMSim.InteractionDiffusion.AbstractDiffusingEmitter}, DiffusionSMLMConfig, Float64}"><code>SMLMSim.InteractionDiffusion.update_system</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_system(emitters::Vector{&lt;:AbstractDiffusingEmitter}, params::DiffusionSMLMConfig, dt::Float64)</code></pre><p>Update all emitters based on Smoluchowski diffusion dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>emitters::Vector{&lt;:AbstractDiffusingEmitter}</code>: Current emitters state</li><li><code>params::DiffusionSMLMConfig</code>: Simulation parameters</li><li><code>dt::Float64</code>: Time step</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:AbstractDiffusingEmitter}</code>: Updated emitters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L188-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.simulate-Tuple{DiffusionSMLMConfig}"><a class="docstring-binding" href="#SMLMSim.simulate-Tuple{DiffusionSMLMConfig}"><code>SMLMSim.simulate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate(params::DiffusionSMLMConfig;
         starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractDiffusingEmitter}}=nothing,
         photons::Float64=1000.0,
         override_count::Union{Nothing, Int}=nothing,
         kwargs...)</code></pre><p>Run a Smoluchowski diffusion simulation and return a BasicSMLD object with emitters that have both frame number and timestamp information.</p><p><strong>Arguments</strong></p><ul><li><code>params::DiffusionSMLMConfig</code>: Simulation parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>starting_conditions::Union{Nothing, SMLD, Vector{&lt;:AbstractDiffusingEmitter}}=nothing</code>: Optional starting emitters</li><li><code>photons::Float64=1000.0</code>: Number of photons per emitter</li><li><code>override_count::Union{Nothing, Int}=nothing</code>: Optional override for the number of molecules</li><li><code>camera::Union{Nothing, AbstractCamera}=nothing</code>: Camera model (default: IdealCamera with 100nm pixels)<ul><li>If <code>nothing</code>, creates IdealCamera with dimensions matching box_size</li><li>Can specify SCMOSCamera for realistic noise modeling</li></ul></li><li>Any additional parameters are ignored (allows unified interface with other simulate methods)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{BasicSMLD, SimInfo}</code>: (smld, info)<ul><li>smld: SMLD object containing all emitters across all frames</li><li>info: SimInfo containing timing and simulation statistics</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Set up parameters with camera settings
params = DiffusionSMLMConfig(
    density = 0.5,           # molecules per μm²
    box_size = 10.0,         # μm
    camera_framerate = 20.0, # 20 fps
    camera_exposure = 0.04   # 40ms exposure
)

# Run basic simulation
smld, info = simulate(params)

# Run simulation with exactly 2 particles
smld, info = simulate(params; override_count=2)

# Use previous simulation state as starting conditions for a new simulation
final_frame = maximum([e.frame for e in smld.emitters])
final_state_emitters = filter(e -&gt; e.frame == final_frame, smld.emitters)
smld_continued, info = simulate(params; starting_conditions=final_state_emitters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/diffusion/smoluchowski.jl#L340-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages"><a class="docstring-binding" href="#SMLMSim.CameraImages"><code>SMLMSim.CameraImages</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">CameraImages</code></pre><p>Module for generating simulated camera images from SMLM data.</p><p>This module provides functions to:</p><ol><li>Generate ideal camera images by integrating emitter photons over a PSF.</li><li>Add realistic camera noise (e.g., Poisson noise).</li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using SMLMSim.CameraImages</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/CameraImages.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.gen_image-Tuple{SMLMData.AbstractSMLD, AbstractPSF, Int64}"><a class="docstring-binding" href="#SMLMSim.CameraImages.gen_image-Tuple{SMLMData.AbstractSMLD, AbstractPSF, Int64}"><code>SMLMSim.CameraImages.gen_image</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gen_image(smld::SMLD, psf::AbstractPSF, frame::Int; kwargs...) -&gt; Tuple{Matrix{T}, ImageInfo} where T&lt;:Real</code></pre><p>Generate a single camera image for a specific frame from SMLD data. See <code>gen_images</code> for full documentation of parameters.</p><p><strong>Returns</strong></p><ul><li><code>Tuple{Matrix{T}, ImageInfo}</code>: (image, info)<ul><li>image: 2D camera image as Matrix{T}</li><li>info: ImageInfo containing timing and image statistics</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/gen_images.jl#L149-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.gen_images-Tuple{SMLMData.AbstractSMLD, AbstractPSF}"><a class="docstring-binding" href="#SMLMSim.CameraImages.gen_images-Tuple{SMLMData.AbstractSMLD, AbstractPSF}"><code>SMLMSim.CameraImages.gen_images</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gen_images(smld::SMLD, psf::AbstractPSF; kwargs...) -&gt; Tuple{Array{T, 3}, ImageInfo} where T&lt;:Real</code></pre><p>Generate camera images from SMLD data using the specified PSF model.</p><p><strong>Arguments</strong></p><ul><li><code>smld::SMLD</code>: Single molecule localization data container</li><li><code>psf::AbstractPSF</code>: Point spread function model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>dataset::Int=1</code>: Dataset number to use from SMLD</li><li><code>frames=nothing</code>: Specific frames to generate (default: all frames in smld.n_frames)</li><li><code>support::Union{Real,Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}}=Inf</code>: PSF support region size:<ul><li><code>Inf</code> (default): Calculate PSF over the entire image (most accurate but slowest)</li><li><code>Real</code>: Circular region with specified radius (in microns) around each emitter</li><li><code>Tuple{&lt;:Real,&lt;:Real,&lt;:Real,&lt;:Real}</code>: Explicit region as (xmin, xmax, ymin, ymax) in microns</li></ul></li><li><code>sampling::Int=2</code>: Supersampling factor for PSF integration</li><li><code>threaded::Bool=true</code>: Enable multithreading for faster computation</li><li><code>bg::Float64=0.0</code>: Background signal level (photons per pixel)</li><li><code>poisson_noise::Bool=false</code>: Apply Poisson noise only (for simple shot noise)</li><li><code>camera_noise::Bool=false</code>: Apply full camera noise model (requires SCMOSCamera)<ul><li>For SCMOSCamera: applies QE, Poisson, read noise, gain, and offset</li><li>For IdealCamera: ignored (use poisson_noise instead)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Array{T,3}, ImageInfo}</code>: (images, info)<ul><li>images: 3D array of camera images with dimensions [height, width, num_frames]</li><li>info: ImageInfo containing timing and image statistics</li></ul></li></ul><p><strong>Performance Note</strong></p><p>For the <code>support</code> parameter, using a finite radius (typically 3-5× the PSF width) provides a good balance between accuracy and performance. For example, with a PSF width of 0.15μm, a support radius of 0.5-1.0μm is usually sufficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/gen_images.jl#L3-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.poisson_noise!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#SMLMSim.CameraImages.poisson_noise!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>SMLMSim.CameraImages.poisson_noise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">poisson_noise!(image::AbstractArray{T}) where T&lt;:Real -&gt; nothing</code></pre><p>Apply Poisson noise to an image or image stack in-place.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractArray{T}</code>: Input image or image stack with values representing photon counts</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The input array is modified in-place</li></ul><p><strong>Details</strong></p><p>Same as <code>poisson_noise</code>, but modifies the input array directly instead of creating a new one. This can be more memory-efficient for large images or when processing multiple frames.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Add Poisson noise to an image in-place
image = ones(100, 100) * 100.0  # 100 expected photons per pixel
poisson_noise!(image)  # image is modified in-place</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/noise.jl#L42-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.poisson_noise-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#SMLMSim.CameraImages.poisson_noise-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>SMLMSim.CameraImages.poisson_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">poisson_noise(image::AbstractArray{T}) where T&lt;:Real -&gt; Array{Float64}</code></pre><p>Apply Poisson noise to an image or image stack.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractArray{T}</code>: Input image or image stack with values representing photon counts</li></ul><p><strong>Returns</strong></p><ul><li>Array with same dimensions as input, with Poisson noise applied to each pixel</li></ul><p><strong>Details</strong></p><p>This function creates a copy of the input array and applies Poisson noise  to each pixel using the in-place poisson_noise! function.</p><p>Non-integer and negative values are handled specially:</p><ul><li>Non-integer values are accepted (treating them as expected photon counts)</li><li>Negative values are clipped to zero before applying noise</li><li>Zero values remain zero (as Poisson(0) always returns 0)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Add Poisson noise to a clean image
clean_image = ones(100, 100) * 100.0  # 100 expected photons per pixel
noisy_image = poisson_noise(clean_image)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/noise.jl#L4-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.scmos_noise!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T&lt;:Real"><a class="docstring-binding" href="#SMLMSim.CameraImages.scmos_noise!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T&lt;:Real"><code>SMLMSim.CameraImages.scmos_noise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scmos_noise!(image::AbstractMatrix{T}, camera::SCMOSCamera) where T&lt;:Real -&gt; nothing</code></pre><p>Apply realistic sCMOS camera noise model to an image in-place.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractMatrix{T}</code>: Input image with values representing photon counts (modified in-place)</li><li><code>camera::SCMOSCamera</code>: sCMOS camera with calibration parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The input array is modified in-place</li></ul><p><strong>Details</strong></p><p>Same as <code>scmos_noise</code>, but modifies the input array directly instead of creating a new one.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">camera = SCMOSCamera(128, 128, 0.1, 1.6)
image = ones(128, 128) * 100.0
scmos_noise!(image, camera)  # image is modified in-place</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/noise.jl#L157-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SMLMSim.CameraImages.scmos_noise-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T&lt;:Real"><a class="docstring-binding" href="#SMLMSim.CameraImages.scmos_noise-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SCMOSCamera}} where T&lt;:Real"><code>SMLMSim.CameraImages.scmos_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scmos_noise(image::AbstractMatrix{T}, camera::SCMOSCamera) where T&lt;:Real -&gt; Matrix{Float64}</code></pre><p>Apply realistic sCMOS camera noise model to an image.</p><p><strong>Arguments</strong></p><ul><li><code>image::AbstractMatrix{T}</code>: Input image with values representing photon counts</li><li><code>camera::SCMOSCamera</code>: sCMOS camera with calibration parameters (offset, gain, readnoise, qe)</li></ul><p><strong>Returns</strong></p><ul><li>Matrix with same dimensions as input, with full sCMOS noise model applied</li></ul><p><strong>Details</strong></p><p>The sCMOS noise model applies the following transformations in order:</p><ol><li>Quantum efficiency: Convert photons to photoelectrons</li><li>Poisson noise: Shot noise on photoelectrons</li><li>Read noise: Gaussian noise per pixel</li><li>Gain: Convert electrons to ADU (analog-to-digital units)</li><li>Offset: Add dark level</li></ol><p>The process simulates the physical detection chain:</p><ul><li>QE: Not all photons generate photoelectrons</li><li>Poisson: Fundamental shot noise</li><li>Read noise: Electronic noise from amplifier/ADC</li><li>Gain &amp; Offset: Conversion to digital units</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create an sCMOS camera with 1.6 e⁻ read noise
camera = SCMOSCamera(128, 128, 0.1, 1.6)

# Apply realistic noise to a clean image
clean_image = ones(128, 128) * 100.0  # 100 photons per pixel
noisy_image = scmos_noise(clean_image, camera)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSMLM/SMLMSim.jl/blob/fbe92f2dc2ce76440c18c022b98d52b786693684/src/camera_images/noise.jl#L81-L116">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../images/">« Microscope Images</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 8 February 2026 23:15">Sunday 8 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
